---
title: 'Windows 최신 IME의 이중 입력 버그, Race Condition을 트릭으로 해결하기'
desc: Windows 11의 최신 IME 환경에서 발생하는 인증 코드 이중 입력 버그의 원인 '경합 상태'를 분석하고, onCompositionEvent의 한계를 넘어 readOnly 속성을 활용해 해결한 과정을 공유합니다.
date: 2025-07-15
thumbnail: /posts/workLog/windowsIME/thumb.avif
---

<h1>나는 숫자 '1'을 눌렀을 뿐인데</h1>

### 1. 의문의 버그 리포트: "숫자가 두 번 입력돼요"

어느 날, 고객으로부터 간단하지만 이상한 문의가 접수되었습니다.

> "Windows 11 환경에서 인증 코드를 입력하는데 숫자 하나를 누르면 두 칸에 똑같은 숫자가 입력됩니다."

6자리 인증 코드를 입력하는 평범한 OTP인증 컴포넌트였습니다. 제 맥북에서는 어떤 방식으로 테스트해도 문제가 발생하지 않았습니다. 심지어 테스트용 Windows PC에서도 버그는 재현되지 않았습니다.

추가 확인 사항을 고객에게 확인해보았습니다.
```bash
- 事象が確認されたOS（windows/mac OSなど） 문제가 발생하는 OS

→Windows11PRO

- 事象が確認された利用ブラウザ（microsoft edge/chromeなど） 문제가 확인된 브라우저

→microsoft edge

- 別のブラウザを使用したときに、同じ事象が発生するか。 다른 브라우저를 사용할 때 같은 문제가 발생하는지

→発生する 발생한다

- お客様の別のPCで、同じ事象が発生するか。 다른 PC에서 같은 문제가 발생하는지

→発生する 발생한다
```

"고객의 PC 환경 문제일까?" 라고 생각했지만 고객은 다른 PC에서도 동일한 문제가 발생한다고 알려주었습니다.

다른 곳에 입력하는 것은 문제없고 이 컴포넌트에서만 발생했기에 단순한 문제가 아님을 직감했습니다.

### 2. 범인은 '최신 Windows IME'

맥북과 윈도우 PC의 차이점과 인터넷 검색으로 알아낸 것은 역시 **IME(입력기)** 에 무언가 문제가 있다! 였습니다.

"혹시 IME 버전의 문제일까?"

이 가설에 의심이 들었던 저는, 직접 윈도우 PC의 설정으로 들어가 관련 옵션을 찾아보기 시작했습니다. 그리고 마침내 결정적인 단서를 찾아냈습니다.

`설정 > 시간 및 언어 > 언어 및 지역 > 일본어 > Microsoft IME > 일반` 경로에 있는 **이전 버전의 Microsoft IME 사용** 이라는 옵션이었습니다.

![windowsIME option off](/posts/workLog/windowsIME/windowsIME.avif)
이 옵션을 껐을 때(즉, 최신 IME를 사용할 때) 거짓말처럼 버그가 100% 재현되었습니다. 범인은 **새로운 Windows IME**와 인증 컴포넌트의 상호작용이 문제인 것이 밝혀졌습니다.

새로운 IME는 이벤트 발생 타이밍이 기존과 달라 인증 컴포넌트의 `onInput` 이벤트와 포커스 이동 로직 사이에 후속 이벤트를 발생시켜 이중 입력 문제를 일으켰던 것입니다.

보통의 경우에는 이러한 입력 문제는 발생하지 않았지만 인증 컴포넌트의 경우 숫자가 입력되면 자동으로 다음 입력창으로 포커스를 이동하도록 만들어 놓았습니다.

이 포커스 이동이라는 이벤트와 IME의 입력 타이밍이 서로 충돌하여 두 번 입력되는 버그가 발생한 것입니다.

**첫 번째 해결책: `onCompositionEvent`**

IME 문제에 대한 표준적인 해결책은 `onCompositionStart/End` 이벤트를 사용하여 IME의 '조합' 상태를 추적하는 것이었습니다. `isComposing`이라는 상태 플래그를 두어 IME가 글자를 조합하는 동안에는 로직 실행을 막고 조합이 끝났을 때만 실행하도록 코드를 수정했습니다.

```typescript
// 첫 번째 시도
const [isComposing, setIsComposing] = useState(false);
//...
<Input
  onCompositionStart={() => setIsComposing(true)}
  onCompositionEnd={() => setIsComposing(false)}
  onInput={(e) => {
    if (isComposing) return;
    // ... 로직 실행 ...
  }}
/>
```

드디어 이중 입력 버그가 사라졌습니다! 하지만 승리의 기쁨은 잠시 더 교묘한 문제들이 나타났습니다. 바로 **사용자 경험(UX)의 저하**였습니다.

1.  **전각 숫자 문제:** 일본어 IME의 전각 모드에서 숫자를 입력하면 이전에는 즉시 반각으로 변환되었지만 이제는 `Enter` 키를 눌러야만 입력이 확정되었습니다.
2.  **문자 입력 문제:** 원래는 숫자 외의 문자는 아예 입력조차 되지 않았지만 이제는 `か` 같은 문자가 입력창에 잠시 보였다가 `Enter`를 누르면 사라지는 현상이 발생했습니다.

버그를 잡았지만 제품의 완성도는 오히려 떨어졌습니다. 다시 다른 방법을 찾아야 했습니다.

### 3. 계속되는 문제: 비동기, 레이스 컨디션, 그리고 UX

이제 목표는 명확해졌습니다. **버그를 잡되 기존의 UX를 단 하나도 해치지 말 것**

이때부터 다시 IME와의 싸움이 시작되었습니다.

  * **2차 시도 (`useRef` 잠금):** `useState`의 비동기적 특성이 문제일 수 있다는 가설 아래 즉시 값이 반영되는 `useRef`를 이용한 '잠금(Lock)' 장치를 도입했습니다. 한 이벤트가 처리 중일 때는 다른 이벤트가 끼어들지 못하게 막는 방식이었습니다.

  * **3차 시도 (`setTimeout` 트릭):** 하지만 사용자의 입력 속도가 매우 빠를 경우 잠금이 풀린 직후 후속 이벤트가 도착하는 레이스 컨디션이 여전히 존재했습니다. `setTimeout(..., 10)`을 이용해 잠금 해제 타이밍을 미세하게 늦추는 트릭을 사용했습니다.

  * **4차 시도 (UX 개선):** `blur()` 대신 `select()`, 그리고 다시 `setSelectionRange()`로 변경하며 마지막 입력창의 UX를 다듬었습니다.

이제 거의 모든 것이 완벽해 보였습니다. 하지만 마지막 문제가 남았습니다. `onKeyDown`에서 `preventDefault()`로 원치 않는 입력을 막았음에도 불구하고 **숫자가 아닌 문자를 입력할 때 아주 잠시 IME 추천 팝업이 뜨는 문제**가 해결되지 않았습니다.
![이런 추천 팝업..스샷은 맥OS입니다](/posts/workLog/windowsIME/tora.avif)

그래서 이렇게 생각했습니다.
**최신 Windows IME는 웹 표준 이벤트 제어를 일부 무시하고 브라우저 렌더링에 직접 개입한다. 따라서 평범한 방법으로는 이길 수 없다.**

### 4. 마지막 방법: 속성 바꿔버리기

지금까지의 문제를 한 문단으로 요약하면 다음과 같습니다.

최신 Windows IME는 onInput 이벤트 직후 거의 동기적으로 추가 '완료' 이벤트를 발생시키는 것으로 보인다. 인증 코드 컴포넌트는 첫 onInput에서 값을 처리하고 즉시 다음 입력창으로 포커스를 이동시키는데 이때 이 추가 이벤트가 새로 포커스된 입력창을 대상으로 발생하여 onInput 핸들러가 재호출되는 레이스 컨디션(Race Condition)이 발생한다.

이 문제를 해결하기 위해 마지막으로 선택한 방법은 '최후의 수단'이었습니다. IME를 제어할 수 없다면 IME가 동작할 환경 자체를 순간적으로 없애버리는 것입니다.

바로 **`readOnly` 속성을 이용한 강제 초기화** 기법입니다.

```typescript
// IME의 예기치 않은 동작을 강제로 리셋하는 헬퍼 함수
const resetImeState = (target: HTMLInputElement) => {
  target.readOnly = true; // 순간적으로 읽기 전용으로 만들어 IME를 비활성화
  setTimeout(() => {
    target.readOnly = false; // 곧바로 다시 활성화
    target.focus();
    // 마지막 입력창에서는 커서를 숫자 뒤로 이동시켜 UX 유지
    if (!inputs[codeIndex + 1] || codeIndex === 5) {
      target.setSelectionRange(1, 1);
    }
  }, 10);
};
```

숫자가 아니거나 6번째 입력이 끝나는 등 IME 팝업이 나타날 수 있는 모든 문제 상황에서 이 `resetImeState` 함수를 호출했습니다. 입력창을 순간적으로 '읽기 전용'으로 만들었다가 되돌리는 방법입니다. 브라우저가 입력창의 상태를 완전히 재평가하게 만들어 떠 있던 IME 팝업을 강제로 닫아버렸습니다.

이 `readOnly` 트릭과 `useRef` 잠금, 그리고 `onKeyDown`의 선제적 방어까지 세 가지 강력한 기법을 조합한 후에야 문제를 해결하고 기존의 UX를 모두 되찾을 수 있었습니다.

속성을 바꾼다는 점과 아주 빠른 입력을 하면 한 순간 추천 팝업이 노출되는 문제가 신경쓰였지만 현재 상태로는 이것이 최선이 아닐까라고 생각합니다.

-----

### 마치며

이번 버그 해결 과정은 단순한 실수 수정이 아니었습니다. 프론트엔드 개발의 가장 깊은 곳, 브라우저와 운영체제가 상호작용하는 영역을 탐험하는 것과 같았습니다. 이 경험을 통해 배운 것은 다음과 같습니다.

1.  **재현되지 않는 버그는 '환경'의 차이에 답이 있다.**
2.  **표준적인 해결책이 통하지 않을 땐 문제의 근본 원리를 의심해야 한다.**
3.  **사용자의 날카로운 피드백은 어떤 기술 문서보다 훌륭한 길잡이다.**

무엇보다 다른 팀원들도 파악하지 못했던 원인을 발견하고 해결까지 했다는 점에서 자신감을 얻었습니다. 브라우저에 따른 대응을 한 적은 있지만 이렇게 OS차이, IME의 버전에 따른 동작까지 대응한 것은 처음이라 정말 좋은 경험이었다고 생각합니다.

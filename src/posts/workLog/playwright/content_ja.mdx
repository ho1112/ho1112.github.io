---
title: '15分の手動テストを2分に！Docker環境におけるplaywright E2Eテスト導入記'
desc: 15分以上かかっていた複雑な手動E2Eテストを、playwrightとDockerを利用して2分に短縮した過程を共有します。cypressとの比較、環境構築、チームのワークフロー改善。
date: 2025-08-05
thumbnail: /posts/workLog/playwright/thumb.avif
---

## E2Eテスト、最適なツールを探して

最近、私が担当するプロジェクトの安定性をさらに一段階引き上げ、デグレバグを効果的に防止するために、E2E（End-to-End）テストの導入を決定しました。

人材紹介プラットフォームの特性上、企業向けとユーザー向けの相互作用が必要なテストシナリオが必須でしたが、そのプロセスは非常に複雑で、手動で行うと**平均15分以上**の時間がかかっていました。

> #### **15分間の手動テストシナリオ：**
>
> 1.  **`toC`（ユーザー向けプラットフォーム）：** テスト用のユーザーアカウントを新規登録します。
> 2.  **`toB`（企業向けプラットフォーム）：** 企業アカウントでログインし、先ほど登録した`toC`アカウントにオファーを送ります。
> 3.  **`toC`：** 再び`toC`アカウントでログインし、受け取ったオファーを確認して**承諾**します。
> 4.  **`toB`：** `toC`の承諾を確認し、チャットを開始します。
> 5.  **`toB`：** 候補者リストを**CSVファイルでダウンロード**し、候補者の**詳細画面**を確認します。
> 6.  **`toB`：** 最終的に候補者を**内定**処理し、`toC`で**内定を承諾**する過程まで確認します。
> 7.  **`toB`：** イベント作成ページに移動。必須項目と日付を設定し、イベント用の画像をアップロードしてイベントの公開リクエストを送ります。

この退屈で反復的なプロセスを自動化するために、いくつかのツールを検討し、現在E2Eテストで最も注目されている2つのツール、**playwright**と**cypress**をまず比較分析しました。

---

## playwright vs cypress
![npm trends](/posts/workLog/playwright/npm_trend.avif)
まずダウンロード数を比較してみると、最近の雰囲気はplaywrightがcypressを上回っています。わずか数年前までcypressがE2Eテスト市場をリードしていたことを考えると、非常に興味深い変化です。この逆転現象が、私が両ツールを改めて深く比較するようになった重要なきっかけの一つでした。

![playwrightとcypressの主な違いの比較](/posts/workLog/playwright/playwrightvscypress.avif)
### playwrightの主な特徴

* **多様な言語サポート：** JavaScript, TypeScript, Python, Java, C#
* **コードなしのテスト生成：** テストジェネレータ(Codegen)を通じてコード作成なしでテスト制作が可能
* **クロスプラットフォーム：** Windows, macOS, Linuxをサポート
* **ネイティブなマルチブラウザサポート：** Chromium(Chrome), Firefox, WebKit(Safari)
* **多様なテストタイプをサポート：** APIテスト, ビジュアルデグレテスト, コンポーネントテスト
* **テストの並列処理**と独立したブラウザコンテキスト
* **HeadlessおよびHeadedモード**による高速実行
* **Trace Viewer**のような高度なデバッグツール
* **ネットワークレベルのテスト：** リクエストを傍受したり、レスポンスを操作可能
* **CI/CDパイプライン**との容易な統合

### cypressの主な特徴

* **言語サポート：** JavaScript, TypeScript (Webアプリに集中)
* **インタラクティブなテストランナー：** 対話可能なGUIテスト実行環境を提供
* **自動待機、リトライロジック、タイムトラベルデバッグ**機能
* **強力なネットワークモッキング(Mocking)およびスタビング(Stubbing)** ツール
* 非同期処理のための独自の**ドット記法(dot-notation)言語**
* **Chromiumベースのブラウザ**の自動化をサポート
* フロントエンドテストに集中しているが、APIテストもサポート
* 優れた公式ドキュメント
* ブラウザの内部(internals)に直接アクセスして状態を操作可能

---

### 主な違いと選択

両ツールとも素晴らしいですが、私のプロジェクトの要件と長期的なビジョンを考慮したとき、いくつかの決定的な違いがありました。

1.  **ブラウザのサポート範囲：「実行可能」と「ネイティブサポート」の違い**
    cypressはChromiumベースのブラウザに非常に強力ですが、SafariのエンジンであるWebKitのサポートは実験的であり、playwrightのモジュールを使用する方式です。一方、playwrightは**WebKitをネイティブで完璧にサポート**します。多様なユーザー環境での一貫した動作を保証する必要がある私にとって、これは非常に重要なポイントでした。

2.  **アーキテクチャと速度：真の並列処理能力**
    playwrightはブラウザの外部で独立したプロセスとしてテストを実行するため、**完全な並列テスト**が可能です。これはテストケースが増えるほどCI/CDパイプラインの実行時間を大幅に短縮させる決定的な利点です。cypressも並列実行をサポートしていますが、アーキテクチャの違いにより、playwrightの並列処理効率の方が高いと判断しました。

3.  **テスト領域の拡張性**
    cypressがフロントエンドのE2Eテストに集中しているのに対し、playwrightは一つのツールで**APIテスト、ビジュアルデグレテスト、コンポーネントテスト**まで公式にサポートしています。将来的にテスト戦略が拡張される可能性を考慮すると、playwrightのこの多才さは大きな利点として感じられました。

4.  **デバッグ体験：失敗の原因を探す旅**
    cypressのタイムトラベルデバッグは素晴らしいです。しかし、playwrightの**Trace Viewer**は、失敗したテストのすべて（スクリーンショット、ネットワークログ、DOMスナップショット、コンソール）を一つのファイルに完璧に記録して提供します。特にCIサーバーで発生した原因不明のエラーを分析する際、この機能はデバッグ時間を劇的に短縮してくれると期待しました。

これらの比較分析を通じて、私はplaywrightが当面の要件を満たすだけでなく、将来の拡張性、開発体験、テストの安定性の面でも最も適した選択であるという結論に至りました。
そして<small>**実は他の現場でcypressを使ったことがあったので、新しいことを試してみたかったんです。😈**</small>

---

## テストアーキテクチャの設計

最初に決定すべきことは、「テストをどこで実行するか？」でした。開発環境はDockerコンテナの内部で実行されていました。

* **選択肢1：Docker内部でテストを実行：** アプリとテスト環境を一致させることができますが、GUIのないサーバー環境でブラウザを立ち上げるために複雑なシステム依存関係をインストールする必要があり、何よりもplaywrightの強力なデバッグツールである**UIモード**を使用できないという致命的な欠点がありました。

* **選択肢2：Docker外部（ローカルマシン）でテストを実行：** この方式は、Dockerで実行中のアプリにローカルマシンのブラウザが接続してテストする構造です。開発者は実際のブラウザウィンドウを目で見ながらデバッグ(`headless: false`)したり、UIモードを100%活用できるため、**開発およびデバッグの生産性**が圧倒的に高いと判断しました。

私は**アプリはDockerで、テスト実行はローカルマシンで**という第二の戦略を選択しました。

-----

## テスト環境の開発ステップ

理論的な探求を終え、私は次のようなステップで実際のテスト環境を構築しました。

### 1段階：依存関係のインストール

まず最初に`web`（作業するプロジェクトのルートパスです）でplaywrightを開発依存関係(`devDependency`)としてインストールしました。

```bash
# webフォルダ内で実行
npm install -D @playwright/test
```

このコマンドは`web/package.json`ファイルに以下のような行を追加します。

```json
// web/package.json
"devDependencies": {
  "@playwright/test": "^1.53.2"
}
```

![UIモード](/posts/workLog/playwright/ui_mode.avif)
インストールを終えて`npx playwright test --ui`を実行すると、このようなUIモードが開かれることを確認できます。

### 2段階：configの設定

`playwright.config.ts`ファイルはE2Eテストのコントロールタワーです。このファイル一つでテストのすべての動作方法を制御できます。次のような主要なオプションを設定しました。

  * `testDir`：テストファイル（`*.spec.ts`）が配置されているフォルダを指定します。`path.resolve`を使用して、どの場所でコマンドを実行しても常に正確なパスを指すように設定しました。
  * `globalSetup`：すべてのテストスイートが実行される前に一度だけ実行される事前設定スクリプト（`global-setup.ts`）のパスを指定します。
  * `use.storageState`：`globalSetup`で生成したログインセッションのスナップショット（`storageState.json`）をすべてのテストが再利用するように設定し、反復的なログインを防ぎます。
  * `projects`：Chromium, WebKit, Firefoxなど、どのブラウザ環境でテストを実行するかを定義します。
  * `reporter`：テスト実行後の結果をどのような形式で表示するかを設定します。私は`html`レポーターを使用して、失敗したテストを視覚的に簡単に分析できるようにしました。

### 3段階：自動ログインの実装

`global-setup.ts`ファイルは、playwrightが実行されると自動的に実行するタスクを設定できます。事前に必要な作業を設定しておく用途で使用します。今回のテストでは、環境変数を読み込んで`local`または`staging`環境に適したテストアカウントでログインし、その結果を`storageState.json`ファイルに保存するようにしました。また、テストの妨げになるポップアップモーダルを事前に無効化するなど、クリーンなテスト環境を作る役割も担っています。

### 4段階：実際のテスト作成

`*.spec.ts`ファイルは、実際のユーザーシナリオをコードで作成する場所です。playwrightは`test`と`expect`という関数を通じて、非常に直感的にテストを作成できるように支援します。
実際の作業では、画面上に表示される要素のチェックの他にも、GraphQLの検知、URLチェックなどを追加して、さらに安定性を高めました。

#### テストコードの例
```typescript
// tests/login.spec.ts

// 1. playwrightの主要な関数であるtestとexpectをインポートします。
import { test, expect } from '@playwright/test'

// 2. 'test'関数で一つのテストケースを定義します。
//    - 最初の引数はテストの名前（説明）です。
//    - 2番目の引数である非同期関数(async)の中に実際のテストロジックが入ります。
//    - { page } はplaywrightが提供する仮想ブラウザのタブオブジェクトです。
test('ユーザーはログインページに移動してログインできる', async ({ page }) => {

  // --- 準備 ---
  // 3. 特定のページに移動します。
  await page.goto('/login')

  // --- 行動 ---
  // 4. 要素を見つけてユーザーの行動（入力、クリックなど）を模倣します。
  await page.getByRole('textbox', { name: 'メールアドレス' }).fill('test@example.com')
  await page.getByRole('textbox', { name: 'パスワード' }).fill('password123')
  await page.getByRole('button', { name: 'ログイン' }).click()

  // --- 検証 ---
  // 5. 行動の結果が我々の予想(expect)と同じか確認します。
  //    'ダッシュボード'というテキストが画面に表示されているか(toBeVisible)を検証します。
  await expect(page.getByText('ダッシュボード')).toBeVisible()
})
```

#### Inspectorモード
![Inspector](/posts/workLog/playwright/inspector.avif)
playwrightにはInspectorモードという機能が存在します。
実際のブラウザでテスト操作を行うと、テストコードが記録されるモードです。生成されたコードをそのままコピーして使用できるため、より迅速な開発が可能になります。
ただし、idやclassでコードを作成するわけではないため、画面上に表示されるテキスト値が変更されると動作しないテストコードになってしまうので注意が必要です。

> npx playwright open [google.co.jp](http://google.co.jp/) —> 探索
> npx playwright codegen [google.co.jp](http://google.co.jp/) —> テストコードの自動生成

`open`、`codegen`コマンドで実行可能で、違いはrecordボタンがオンの状態で始まるかどうかの差です。

### 5段階：プロジェクトをクリーンに保つ

テストを実行すると、いくつかの結果ファイルが生成されます。これらのファイルがgitの履歴に含まれないように`.gitignore`に追加しました。

  * `playwright-report/`, `test-results/`：テスト実行後に生成されるHTMLレポートと結果物です。毎回変わるため、バージョン管理から除外します。
  * `storageState.json`：ログインセッション情報が格納されたファイルです。機密情報である可能性があり、実行のたびに生成されるため、バージョン管理から除外します。

### 6段階：テストデータの準備

単にDBに存在するだけの「空っぽ」のアカウントでは、複雑なシナリオをテストできませんでした。既存のダミーデータ生成用のSeederを修正し、**実際にログインが可能で、テストに必要なすべての情報（特定の検索キーワードなど）を備えた**ユーザーを生成するように改善しました。約200のテストアカウントを事前に生成し、どのテストを実行してもデータ不足で失敗しないように備えました。

-----

## チームのための最適なワークフローを探して

これで技術的な構成は終わりましたが、最も重要なのは「チームメンバーがこの環境をどれだけ簡単に使えるか？」でした。

### scriptの代わりにTaskを選んだ理由
結論から言うと、テストの実行をスクリプトではなくTaskで行うことにしました。
`package.json`のスクリプトも良い方法ですが、決定的な理由はディレクトリを指定する必要があったからです。`dir: ***`

  * `package.json`のスクリプトは常にプロジェクトのルートで実行されます。テストは`web`フォルダを基準に実行されるべきなので、`npx --prefix web ...`のようにコマンドが複雑になり、パス設定が紛らわしくなりがちでした。
  * `Taskfile.yml`の`dir: web`オプションは、タスクの実行位置自体を`web`フォルダに指定してくれるため、はるかにすっきりと直感的なコマンドを作ることができました。

また、チームメンバーが事前にブラウザをインストールしなくてもいいように、テスト実行コマンドに`npx playwright install`を含め、タスクが自ら実行環境を保証するようにしました。

```yaml
# /Taskfile.yml
test-e2e-local:
  desc: "E2Eテスト(playwright)をlocal環境で実行"
  aliases: [tel]
  dir: web # ★ この一行のおかげで、すべてがシンプルになります。
  env:
    NEXT_PUBLIC_APP_ENV: local
  cmds:
    - npx playwright install # 実行時にブラウザのインストールを自動確認
    - npx playwright test --config=e2e/setting/playwright.config.ts {{.CLI_ARGS | default "--ui"}}
```

そして、このように追加したTaskコマンドを`README.md`に追加してチームメンバーに共有しました。

---
## おわりに

これらすべての努力の結果、**手動で15分以上かかっていた必須のテストプロセスが自動化され、わずか2分前後へと短縮されました。**

実際の運用環境ではテストデータと実際のユーザーデータが分離されていないため、local、staging環境でしか実行できないという制約がありましたが、デプロイ前のテストにかかる時間を画期的に減らし、開発チームの生産性を大幅に向上させることができました。

E2Eテストの導入は、単にコードを書くことを超えて、チームのワークフロー全体を考慮し、安定的でありながら使いやすいシステムを設計するプロセスだったと思います。

E2Eテストは継続的なメンテナンスが必要な作業ですが、その分リソースを節約でき、反復的な手動テストから来る疲労感を減らして、開発環境を一層快適にしてくれると思います。
<small>**毎回の反復作業はヒューマンエラーが起こる可能性もありますし…** 🤫</small>
このように確保された時間と安定した環境は、結果的にチーム全体の生産性を高める好循環につながり、長期的に見て全員にとって有益な最も確実な投資だと考えています。

---

#### 🔗 参考
[https://npmtrends.com/cypress-vs-playwright](https://npmtrends.com/cypress-vs-playwright)
[https://www.checklyhq.com/learn/playwright/playwright-vs-cypress/](https://www.checklyhq.com/learn/playwright/playwright-vs-cypress/)
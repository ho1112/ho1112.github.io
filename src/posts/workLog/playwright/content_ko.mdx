---
title: '15분의 수동 테스트를 2분으로! Docker 환경에서 playwright E2E 테스트 도입기'
desc: 15분이 넘게 걸리던 복잡한 수동 E2E 테스트를 playwright와 Docker를 이용해 2분으로 단축한 과정을 공유합니다. cypress와의 비교, 환경 구축, 팀 워크플로우 개선
date: 2025-08-15
thumbnail: /posts/workLog/playwright/thumb.avif
---

## E2E 테스트, 최적의 도구를 찾아서

최근 제가 담당하는 프로젝트의 안정성을 한 단계 더 끌어올리고 리그레이션 버그를 효과적으로 방지하기 위해 E2E(End-to-End) 테스트 도입을 결정했습니다.

인재소개 플랫폼 특성상 기업용과 유저용의 상호작용이 필요한 필수로 수행해야 하는 테스트 시나리오가 있었는데 그 과정이 매우 복잡하여 수동으로 진행 시 **평균 15분 이상**의 시간이 소요되었습니다.

> #### **15분짜리 수동 테스트 시나리오:**
>
> 1.  **`toC` (유저용 플랫폼):** 테스트용 유저 계정을 새로 회원가입 시킵니다.
> 2.  **`toB` (기업용 플랫폼):** 기업 계정으로 로그인하여, 방금 가입한 `toC` 계정에 오퍼를 보냅니다.
> 3.  **`toC`:** 다시 `toC` 계정으로 로그인하여 받은 오퍼를 확인하고 **승낙**합니다.
> 4.  **`toB`:** `toC`의 승낙을 확인하고 채팅을 시작합니다.
> 5.  **`toB`:** 후보자 목록을 **CSV 파일로 다운로드**하고, 후보자의 **상세 화면**을 확인합니다.
> 6.  **`toB`:** 최종적으로 후보자를 **내정** 처리하고, `toC`에서 **내정을 승낙**하는 과정까지 확인합니다.
> 7.  **`toB`:** 이벤트 작성 페이지로 이동. 필수 항목과 날짜를 설정, 이벤트용 이미지를 업로드하고 이벤트 개시 요청을 보낸다.

이 지루하고 반복적인 과정을 자동화하기 위해 여러 도구를 검토했고 현재 E2E 테스트에서 가장 주목받는 두 도구, **playwright**와 **cypress**를 먼저 비교 분석했습니다.

---

## playwrihgt vs cypress
![npm treands](/posts/workLog/playwright/npm_trend.avif)
우선 다운로드 수를 비교해보면 최근 분위기는 playwright가 cypress보다 앞서고 있습니다. 불과 몇 년 전만 해도 cypress가 E2E 테스트 시장을 주도했던 것을 생각하면 매우 흥미로운 변화입니다. 이 역전 현상이 제가 두 도구를 다시 한번 깊이 있게 비교하게 된 중요한 계기 중 하나였습니다.

![playwright vs cypress 주요 차이점 비교](/posts/workLog/playwright/playwrightvscypress.avif)
### playwright 주요 특징

* **다양한 언어 지원:** JavaScript, TypeScript, Python, Java, C#
* **코드 없는 테스트 생성:** 테스트 생성기(Codegen)를 통해 코드 작성 없이 테스트 제작 가능
* **크로스 플랫폼:** Windows, macOS, Linux 지원
* **네이티브 멀티 브라우저 지원:** Chromium(Chrome), Firefox, WebKit(Safari)
* **다양한 테스트 유형 지원:** API 테스트, 비주얼 리그레이션 테스트, 컴포넌트 테스트
* **테스트 병렬 처리** 및 독립적인 브라우저 컨텍스트
* **Headless 및 Headed 모드**를 통한 빠른 실행
* **Trace Viewer**와 같은 고급 디버깅 도구
* **네트워크 레벨 테스트:** 요청을 가로채거나 응답을 조작 가능
* **CI/CD 파이프라인**과의 손쉬운 통합

### cypress 주요 특징

* **언어 지원:** JavaScript, TypeScript (웹 앱에 집중)
* **인터랙티브 테스트 러너:** 상호작용이 가능한 GUI 테스트 실행기 제공
* **자동 대기, 재시도 로직, 시간 여행 디버깅** 기능
* **강력한 네트워크 모킹(Mocking) 및 스터빙(Stubbing)** 도구
* 비동기 처리를 위한 고유의 **닷-노테이션(dot-notation) 언어**
* **Chromium 기반 브라우저** 자동화 지원
* 프론트엔드 테스트에 집중하지만 API 테스트도 지원
* 훌륭한 공식 문서
* 브라우저 내부(internals)에 직접 접근하여 상태 조작 가능

---

### 주요 차이점과 선택

두 도구 모두 훌륭하지만 제 프로젝트의 요구사항과 장기적인 비전을 고려했을 때 몇 가지 결정적인 차이점이 있었습니다.

1.  **브라우저 지원 범위: '실행 가능'과 '네이티브 지원'의 차이**
    cypress는 Chromium 기반 브라우저에 매우 강력하지만 Safari의 엔진인 WebKit 지원은 실험적이며 playwright의 모듈을 사용하는 방식입니다. 반면, playwright는 **WebKit을 네이티브로 완벽하게 지원**합니다. 다양한 사용자 환경에서의 일관된 동작을 보장해야 하는 저에게 이는 매우 중요한 포인트였습니다.

2.  **아키텍처와 속도: 진정한 병렬 처리 능력**
    playwright는 브라우저 외부에서 독립적인 프로세스로 테스트를 실행하여 **완벽한 병렬 테스트**가 가능합니다. 이는 테스트 케이스가 늘어날수록 CI/CD 파이프라인의 실행 시간을 크게 단축시키는 결정적인 장점입니다. cypress도 병렬 실행을 지원하지만 아키텍처의 차이로 인해 playwright의 병렬 처리 효율성이 더 높다고 판단했습니다.

3.  **테스트 영역의 확장성**
    cypress가 프론트엔드 E2E 테스트에 집중하는 반면, playwright는 하나의 도구로 **API 테스트, 비주얼 리그레이션 테스트, 컴포넌트 테스트**까지 공식적으로 지원합니다. 향후 테스트 전략이 확장될 가능성을 고려했을 때 playwright의 이러한 다재다능함은 큰 이점으로 다가왔습니다.

4.  **디버깅 경험: 실패의 원인을 찾는 여정**
    cypress의 시간 여행 디버깅은 훌륭합니다. 하지만 playwright의 **Trace Viewer**는 실패한 테스트의 모든 것(스크린샷, 네트워크 로그, DOM 스냅샷, 콘솔)을 하나의 파일로 완벽하게 기록하여 제공합니다. 특히 CI 서버에서 발생한 원인 불명의 에러를 분석할 때 이 기능은 디버깅 시간을 극적으로 줄여줄 것이라 기대했습니다.

이러한 비교 분석을 통해 저는 playwright가 당장의 요구사항을 충족할 뿐만 아니라 미래의 확장성, 개발 경험, 테스트의 안정성 측면에서도 가장 적합한 선택이라는 결론을 내렸습니다.
그리고 <small>**사실 다른 현장에서 cypress를 사용한 적이 있기에 새로운 것을 해보고 싶었습니다. 😈** </small>

---

## 테스트 아키텍처 설계

가장 먼저 결정해야 할 것은 "테스트를 어디서 실행할 것인가?"였습니다. 개발환경은 Docker 컨테이너 내부에서 실행되고 있었죠.

* **선택지 1: Docker 내부에서 테스트 실행:** 앱과 테스트 환경을 일치시킬 수 있지만 GUI가 없는 서버 환경에서 브라우저를 띄우기 위해 복잡한 시스템 의존성을 설치해야 하고 무엇보다 playwright의 강력한 디버깅 도구인 **UI 모드**를 사용할 수 없다는 치명적인 단점이 있었습니다.

* **선택지 2: Docker 외부(로컬 머신)에서 테스트 실행:** 이 방식은 Docker에서 실행 중인 앱에 로컬 머신의 브라우저가 접속하여 테스트하는 구조입니다. 개발자는 실제 브라우저 창을 눈으로 보며 디버깅(`headless: false`)하거나 UI 모드를 100% 활용할 수 있어 **개발 및 디버깅 생산성**이 압도적으로 높다고 판단했습니다.

저는 **앱은 Docker에서 테스트 실행은 로컬 머신에서**라는 두 번째 전략을 선택했습니다.

-----

## 테스트 환경 개발 단계

이론적인 탐색을 마치고 저는 다음과 같은 단계로 실제 테스트 환경을 구축했습니다.

### 1단계: 의존성 설치

가장 먼저 `web`(작업할 프로젝트의 루트 경로입니다)에서 playwright를 개발 의존성(`devDependency`)으로 설치했습니다.

```bash
# web 폴더 안에서 실행
npm install -D @playwright/test
```

이 명령어는 `web/package.json` 파일에 아래와 같은 라인을 추가합니다.

```json
// web/package.json
"devDependencies": {
  "@playwright/test": "^1.53.2"
}
```

![ui mode](/posts/workLog/playwright/ui_mode.avif)
설치를 마치고 `npx playwright test --ui`를 실행하면 이러한 ui모드가 열리는 것을 확인할 수 있습니다.

### 2단계: config 설정

`playwright.config.ts` 파일은 E2E 테스트의 컨트롤 타워입니다. 이 파일 하나로 테스트의 모든 동작 방식을 제어할 수 있습니다. 다음과 같은 핵심 옵션들을 설정했습니다.

  * `testDir`: 테스트 파일(`*.spec.ts`)들이 위치한 폴더를 지정합니다. `path.resolve`를 사용해 어떤 위치에서 명령어를 실행하든 항상 정확한 경로를 가리키도록 설정했습니다.
  * `globalSetup`: 모든 테스트 스위트가 실행되기 전 단 한 번만 실행될 사전 설정 스크립트(`global-setup.ts`)의 경로를 지정합니다.
  * `use.storageState`: `globalSetup`에서 생성한 로그인 세션 스냅샷(`storageState.json`)을 모든 테스트가 재사용하도록 설정하여 반복적인 로그인을 방지합니다.
  * `projects`: Chromium, WebKit, Firefox 등 어떤 브라우저 환경에서 테스트를 실행할지 정의합니다.
  * `reporter`: 테스트 실행 후 결과를 어떤 형태로 보여줄지 설정합니다. 저는 `html` 리포터를 사용하여 실패한 테스트를 시각적으로 쉽게 분석할 수 있도록 했습니다.

### 3단계: 자동 로그인 구현

`global-setup.ts`파일은 palywright가 실행되면 자동으로 실행할 작업을 설정할 수 있습니다. 사전에 필요한 작업들을 설정해놓는 용도로 사용합니다. 이번 테스트에서는 환경 변수를 읽어 `local` 또는 `staging` 환경에 맞는 테스트 계정으로 로그인하고 그 결과를 `storageState.json` 파일에 저장하도록 했습니다. 또한, 테스트에 방해가 되는 팝업 모달들을 미리 비활성화하는 등 깨끗한 테스트 환경을 만드는 역할도 담당합니다.

### 4단계: 실제 테스트 작성

`*.spec.ts` 파일은 실제 사용자 시나리오를 코드로 작성하는 곳입니다. playwright는 `test`와 `expect`라는 함수를 통해 매우 직관적으로 테스트를 작성할 수 있도록 돕습니다.
실제 작업 시에는 화면 상에 보여지는 요소의 체크 외에도 graphql 감지, url체크 등을 추가하여 더욱 안정성을 높였습니다.

#### 테스트 코드 예시
```typescript
// tests/login.spec.ts

// 1. playwright의 핵심 함수인 test와 expect를 임포트합니다.
import { test, expect } from '@playwright/test'

// 2. 'test' 함수로 하나의 테스트 케이스를 정의합니다.
//    - 첫 번째 인자는 테스트의 이름(설명)입니다.
//    - 두 번째 인자인 비동기 함수(async) 안에 실제 테스트 로직이 들어갑니다.
//    - { page }는 playwright가 제공하는 가상 브라우저 탭 객체입니다.
test('사용자는 로그인 페이지로 이동하여 로그인할 수 있다', async ({ page }) => {

  // --- 준비 ---
  // 3. 특정 페이지로 이동합니다.
  await page.goto('/login')

  // --- 행동 ---
  // 4. 요소를 찾아서 사용자의 행동(입력, 클릭 등)을 흉내냅니다.
  await page.getByRole('textbox', { name: '이메일' }).fill('test@example.com')
  await page.getByRole('textbox', { name: '비밀번호' }).fill('password123')
  await page.getByRole('button', { name: '로그인' }).click()

  // --- 검증 ---
  // 5. 행동의 결과가 우리가 예상(expect)한 것과 같은지 확인합니다.
  //    '대시보드'라는 텍스트가 화면에 보이는지(toBeVisible) 검증합니다.
  await expect(page.getByText('대시보드')).toBeVisible()
})
```

#### inspector 모드
![inspector](/posts/workLog/playwright/inspector.avif)
playwright에는 inspector 모드라는 기능이 존재합니다.
실제 브라우저에서 테스트 동작을 하면 테스트 코드가 기록되는 모드입니다. 생성된 코드를 그대로 복사해서 사용하면 되기에 더욱 빠른 개발이 가능해집니다.
단 id, class로 코드를 작성하는 것이 아니기에 화면 상에 보여지는 텍스트 값이 변경되면 동작하지 않는 테스트 코드가 되어버리기에 주의할 필요가 있습니다.

> npx playwright open [google.co.jp](http://google.co.jp/) —> 탐색
> npx playwright codegen [google.co.jp](http://google.co.jp/) —> 테스트 코드 자동 생성

`open`, `codegen` 커맨드로 실행가능하며 차이점은 record 버튼이 켜진 상태로 시작하냐 아니냐의 차이입니다.

### 5단계: 프로젝트를 깔끔하게

테스트를 실행하면 여러 결과 파일들이 생성됩니다. 이런 파일들이 git 히스토리에 포함되지 않도록 `.gitignore`에 추가했습니다.

  * `playwright-report/`, `test-results/`: 테스트 실행 후 생성되는 HTML 리포트와 결과물입니다. 매번 바뀌므로 버전 관리에서 제외합니다.
  * `storageState.json`: 로그인 세션 정보가 담긴 파일입니다. 민감할 수 있고 실행할 때마다 생성되므로 버전 관리에서 제외합니다.

그리고 기존에 jest를 사용하고 있었다면 playwright의 파일들까지 테스트 대상이 되어버립니다.
jest.config에 testPathIgnorePatterns를 추가, playwright 경로를 지정해서 테스트 대상에서 제외하도록 했습니다.

```typescript
export default {
  ...
  rootDir: './',
  // ↓ playwright의 경로를 추가
  testPathIgnorePatterns: ['<rootDir>/playwright/']
}
```

### 6단계: 테스트 데이터 준비

단순히 DB에 존재하기만 하는 '깡통' 계정으로는 복잡한 시나리오를 테스트할 수 없었습니다. 기존의 더미 데이터 생성용 Seeder를 수정하여 **실제로 로그인이 가능하고 테스트에 필요한 모든 정보(특정 검색 키워드 등)를 갖춘** 유저를 생성하도록 개선했습니다. 약 200개의 테스트 계정을 미리 생성하여 어떤 테스트를 실행해도 데이터 부족으로 실패하지 않도록 대비했습니다.

-----

## 팀을 위한 최적의 워크플로우를 찾아서

이제 기술적인 구성은 끝났지만 가장 중요한 것은 "팀원들이 이 환경을 얼마나 쉽게 사용할 수 있는가?"였습니다.

### script 대신 Task를 선택한 이유
결론부터 말하면 테스트의 실행을 스크립트가 아닌 Task로 하도록 결정했습니다.
`package.json`의 스크립트도 좋은 방법이지만 결정적인 이유는 디렉토리를 지정할 필요가 있기 때문이었습니다. `dir: ***`

  * `package.json` 스크립트는 항상 프로젝트 루트에서 실행됩니다. 테스트는 `web` 폴더를 기준으로 실행되어야 하므로, `npx --prefix web ...` 같이 명령어가 복잡해지고 경로 설정이 헷갈리기 쉬웠습니다.
  * `Taskfile.yml`의 `dir: web` 옵션은 태스크의 실행 위치 자체를 `web` 폴더로 지정해주어 훨씬 깔끔하고 직관적인 명령어를 만들 수 있었습니다.

또한 팀원들이 사전에 브라우저를 설치하는 하지 않아도 괜찮도록 테스트 실행 명령어에 `npx playwright install`을 포함시켜 태스크가 스스로 실행 환경을 보장하도록 만들었습니다.

```yaml
# /Taskfile.yml
test-e2e-local:
  desc: "E2Eテスト(playwright)をlocal環境で実行"
  aliases: [tel]
  dir: web # ★ 이 한 줄 덕분에 모든 것이 간단해집니다.
  env:
    NEXT_PUBLIC_APP_ENV: local
  cmds:
    - npx playwright install # 실행 시 브라우저 설치 자동 확인
    - npx playwright test --config=e2e/setting/playwright.config.ts {{.CLI_ARGS | default "--ui"}}
```

그리고 이렇게 추가한 Task 커맨드를 `README.md`에 추가하여 팀원들에게 공유하였습니다.

---
## 마치며

이 모든 노력의 결과 **수동으로 15분 이상 걸리던 필수 테스트 과정이 자동화되어 단 2분 내외로 단축되었습니다.**

실제 운영환경에서는 테스트 데이터와 실제 유저 데이터가 분리되어 있지 않아 local, staging 환경에서만 실행할 수 있다는 제약이 있었지만 배포 전 테스트에 드는 시간을 획기적으로 줄여 개발팀의 생산성을 크게 향상시킬 수 있었습니다.

E2E 테스트 도입은 단순히 코드를 작성하는 것을 넘어 팀의 워크플로우 전체를 고려하여 안정적이면서도 사용하기 쉬운 시스템을 설계하는 과정이었다고 생각합니다.

E2E 테스트는 꾸준한 유지보수가 필요한 작업이지만 그만큼 리소스를 절약할 수 있고 반복적인 수동 테스트에서 오는 피로감을 줄여 개발 환경을 한층 더 쾌적하게 만들어 준다고 생각합니다.
<small>**매번 반복되는 작업은 휴먼 에러가 일어날 확률도 있고...** 🤫</small>
이렇게 확보된 시간과 안정적인 환경은 결국 팀 전체의 생산성을 높이는 선순환으로 이어져 장기적으로 모두에게 도움이 되는 가장 확실한 투자라고 생각합니다.

---

#### 🔗 참고
https://npmtrends.com/cypress-vs-playwright
https://www.checklyhq.com/learn/playwright/playwright-vs-cypress/


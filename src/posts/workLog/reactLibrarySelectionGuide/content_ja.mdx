---
title: 'ライブラリ導入記：チャート、カレンダー、DnD実装のための悩み'
desc: Reactプロジェクトのためのライブラリ導入記。Recharts、react-datepicker、dnd-kitを最終選定した理由と候補群の比較分析。単なる人気ではなく、プロジェクトの状況に合わせた技術選定基準をまとめました。
date: 2026-01-01
thumbnail: /posts/workLog/reactLibrarySelectionGuide/thumbnail.avif
---

## ライブラリ導入記：チャート、カレンダー、そしてDnD機能

開発をしていると、数多くのライブラリの中から一つを選ばなければならない瞬間が訪れます。単に「Starが多いから」、「最近流行っているから」という理由で選ぶと、後で必ず技術的負債として返ってくるものです。

今回の記事では、最近プロジェクトを進める中で**チャート（Chart）、カレンダー（Calendar）、ドラッグ＆ドロップ（DnD）**機能を実装するために検討したライブラリの候補群と、**各候補を1位から下位まで順位付けした具体的な理由**、そして最終決定の根拠をまとめました。

---

## 1. チャート（Chart）ライブラリ
デザイナーが要求したのは、異なる指標を棒グラフと折れ線グラフの2つで表示するダッシュボード画面でした。そこで、現在最も多く使用されているライブラリ、保守（メンテナンス）状況、そして新たに追加する機能の実装を満たせるかを考慮し、3つの候補を選定しました。

チャートライブラリの世界では、**レンダリング方式（SVG vs Canvas）** と **記述方式（コンポーネント vs 設定オブジェクト）** が比較の重要なポイントになります。

![npm trend](/posts/workLog/reactLibrarySelectionGuide/chart.avif)

### 📊 Reactチャートライブラリ総合評価

| 評価項目 | 重み | **1. Recharts** | **2. Chart.js** | **3. Nivo** |
| :--- | :--- | :--- | :--- | :--- |
| **React親和性 (DX)** | High | **5.0 (完璧なJSX)** | 3.5 (Wrapper必要) | 4.5 (コンポーネント) |
| **カスタム (柔軟性)** | High | **5.0 (組み立て式)** | 3.0 (設定オブジェクト) | 4.5 (複雑) |
| **パフォーマンス (大容量)** | Mid | 3.0 (DOM負荷) | **5.0 (Canvas)** | 3.0 (SVG中心) |
| **Next.js互換性** | Mid | 4.0 (Dynamic必要) | 4.0 (Dynamic) | 5.0 (SSR対応) |
| **総点** | - | **🥇 26.5** | **🥈 24.0** | **🥉 21.5** |

### 詳細分析および選定理由

#### 🥇 1位：Recharts（最終選定）
https://recharts.github.io/en-US/
![](/posts/workLog/reactLibrarySelectionGuide/recharts.avif)
* **React開発者が最も快適さを感じる「レゴブロック」方式**
* **選定理由 (React親和性):** `<Bar />`、`<Tooltip />`のようにコンポーネントをJSXの中にポンと配置すれば組み立てられる宣言的（Declarative）な方式です。React開発者なら説明書を見なくても大体どう使えばいいか勘が働くほど直感的です。
* **カスタム柔軟性:** ツールチップをカスタムしたければ、`content={<MyCustomTooltip />}`のように自作したコンポーネントを差し込めば済みます。CSS-in-JSやTailwindとの相性が最高です。
* **短所:** データが数千個（例：株式のティックデータ10年分）を超えるとブラウザが重くなる可能性があります。（SVGレンダリングの限界）しかし、一般的なダッシュボードレベルでは全く問題ないと判断しました。

#### 🥈 2位：Chart.js (react-chartjs-2)
https://www.chartjs.org/
![](/posts/workLog/reactLibrarySelectionGuide/chart.js.avif)
* **パフォーマンスが命であり、標準デザインだけで良いなら**
* **特徴:** Canvas技術を使って絵を一枚の画像のように描画します。大容量データの処理に強いです。
* **脱落理由:** 巨大な`options`オブジェクト一つですべてを制御しなければなりません。「軸の色を変えるには`scales.y.grid.color`を探しに行かないとダメか？」のようにオプション探しゲームをする必要があります。ツールチップの中に複雑なHTML/CSSデザインを入れるには別途プラグインを書いたり、Canvasを直接触る必要があり、難易度が急上昇します。仕様変更と保守が難しくなると考えました。

#### 🥉 3位：Nivo
https://nivo.rocks/
![](/posts/workLog/reactLibrarySelectionGuide/nivo.avif)
* **華やかなデザインのチャートが必要なら**
* **特徴:** インストールするだけでデザイナーがデザインしたような綺麗なチャートと華やかなアニメーションが表示されます。D3.jsをReactでうまくラップした形です。
* **脱落理由:** 一言で言うと「トゥー・マッチ（Too Much）」でした。Propsが多すぎて、簡単な棒グラフを一つ描くだけでも設定することが多いです。単純な現在のサービスのダッシュボード用としてはオーバースペックだと考えました。

> **💡 技術ノート：SVG vs Canvas**
> * **SVG (Recharts, Nivo) = HTMLタグ (DOM):** 棒の一つ一つが`<div>`や`<path>`タグです。開発者ツールで確認でき、CSSホバー効果を与えるのも簡単です。その代わりタグが多くなると遅くなります。
> * **Canvas (Chart.js) = 絵 (Image):** 画用紙一枚にピクセルで描きます。データが多くても速いですが、すでに描かれた絵の特定部分だけスタイルを変えたりイベントを設定したりするのが非常に厄介です。

Rechartsで実際に開発に着手し実装した初期段階のスクリーンショットです。（最終リリースバージョンとは差異があります）
<div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap', justifyContent: 'center', margin: '24px 0' }}>
  <img
    src="/posts/workLog/reactLibrarySelectionGuide/bar.avif"
    style={{
      maxWidth: '100%',
      height: 'auto',
      flex: '1',
      minWidth: '300px',
      borderRadius: '8px',
      boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
    }}
  />
  <img
    src="/posts/workLog/reactLibrarySelectionGuide/line.avif"
    style={{
      maxWidth: '100%',
      height: 'auto',
      flex: '1',
      minWidth: '300px',
      borderRadius: '8px',
      boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
    }}
  />
</div>

---

## 2. カレンダー（Calendar）ライブラリ
要求事項は以下の通りでした。
1. 単一日付選択
2. 月ごとの移動
3. 対象ではない日付はdisabled、先月と来月の日付は非表示
4. デザインのカスタマイズが可能であること

そしてリリース目標まで期限が迫っており、開発工数を減らす必要がありました。そのため、インプット画面を押すとカレンダーが表示される（Input + Popover）機能が必須でした。これを満たす4つの候補群を比較しました。

![npm trend](/posts/workLog/reactLibrarySelectionGuide/calendar.avif)

### 🗓️ カレンダーライブラリ総合評価

| 評価項目 | 重み | **1. react-datepicker** | **2. react-date-picker** | **3. react-datetime** | **4. react-dates** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **安定性/認知度** | Max | **5.0 (圧倒的1位)** | 3.0 (名前混同) | 3.0 (減少傾向) | 3.5 (管理中断) |
| **機能 (Input+Popover)** | Max | **5.0 (内蔵済み)** | 4.0 (武骨) | 3.0 (時間特化) | 2.0 (Range特化) |
| **カスタム容易性** | Mid | 4.0 (CSS上書き) | 3.5 (厄介) | 3.0 (Old Style) | 2.0 (非常に難しい) |
| **バンドルサイズ** | Mid | 4.0 (適当) | 4.0 (適当) | 3.0 (依存性) | 1.0 (非常に重い) |
| **総点** | - | **🥇 18.0** | **🥈 14.5** | **12.0** | **8.5** |

### 詳細分析および選定理由

#### 🥇 1位：react-datepicker（最終選定）
https://reactdatepicker.com/
![](/posts/workLog/reactLibrarySelectionGuide/react-datepicker.avif)
* **「事実上の業界標準（De Facto Standard）。最も安全で速い道」**
* **選定理由:** npmダウンロード数が圧倒的で、バグ発生時にリファレンス（StackOverflowなど）を見つけるのが最も簡単です。我々が必要とする「Input + Popover」形態を標準で提供しており、別途ポータル（Portal）ロジックを組む必要がありません。CSSクラス構造が明確でデザインの上書きも容易でした。

#### 🥈 2位：react-date-picker（類似品注意）
https://github.com/wojtekmaj/react-date-picker#readme
* **「悪くはないが、あえて2位を使う理由はない」**
* **特徴:** `react-calendar`をベースに作られたライブラリです。
* **脱落理由:** 1位である`react-datepicker`と名前がほぼ同じで混同しやすいですが、ユーザー数がはるかに少ないです。機能的に大きな差別化ポイントがないのに、コミュニティサポートが弱いライブラリを選択して冒険をする必要はないと判断しました。

#### 🥉 3位：react-datetime
https://github.com/arqex/react-datetime
* **「時間（Time）選択がメインなら考慮しただろうが…」**
* **特徴:** 日付と時間を同時に選択するUIに特化しています。
* **脱落理由:** デザインが多少古いスタイルであり、最近の保守トレンドから外れています。「日付」がメインであり、時間は別途UIで実装する予定だったため、目的に合いませんでした。

#### 4位：react-dates (Airbnb)
https://github.com/react-dates/react-dates/
![](https://raw.githubusercontent.com/react-dates/react-dates/HEAD/react-dates-demo.gif)
* **「ホテル予約サイトを作るなら1順位だったはず」**
* **特徴:** Airbnbが作ったライブラリで、「開始日〜終了日（Range）」選択UIが非常に強力です。今回の機能は単一日付選択であり終了日が不要だったため、優先順位が下がりました。
* **脱落理由:**
    1.  **Overkill（機能過剰）:** 単純な日付選択には機能が多すぎて複雑です。
    2.  **重い:** 今ではあまり使われない`Moment.js`への強い依存性があり、バンドルサイズが不必要に大きくなります。
    3.  **保守:** 最近管理があまりされておらず、新規プロジェクトへの導入にはリスクが大きいと判断しました。

react-datepickerで実装した実際のサービス完成バージョン
<img src="/posts/workLog/reactLibrarySelectionGuide/calendar_sche.avif" alt="캘린더 구현" width="350" />

---

## 3. ドラッグ＆ドロップ（DnD）ライブラリ
最も悩みが多かった分野です。どんな「感覚」のインタラクションを望むか、そしてどれくらい「カスタム」するかによって選択肢が完全に変わるためです。
デザイナーもどんな方式が可能か分からない状態で、私にまず提案してほしいと言っていた機能でもありました。そのため、デザイン的な側面まで考慮して考えました。

![npm trend](/posts/workLog/reactLibrarySelectionGuide/dnd.avif)

### 🖱️ DnDライブラリ総合評価

| 評価項目 | 重み | **1. dnd-kit** | **2. @formkit** | **3. hello-pangea** |
| :--- | :--- | :--- | :--- | :--- |
| **エコシステム & 未来** | High | **5.0 (標準/活発)** | 3.0 (新興) | 3.5 (保守中心) |
| **カスタム (拡張性)** | Max | **5.0 (Headless)** | 3.0 (Browser依存) | 2.5 (制限的) |
| **Next.js互換性** | High | **5.0 (完全対応)** | 4.5 (良い) | 4.0 (パッチ必要) |
| **バンドルサイズ** | Mid | 4.0 (モジュール式) | **5.0 (超軽量)** | 2.0 (重い) |
| **総点** | - | **🥇 27.0** | **🥈 23.5** | **🥉 20.0** |

### 詳細分析および選定理由

#### 🥇 1位：dnd-kit（最終選定）
https://dndkit.com/
![](/posts/workLog/reactLibrarySelectionGuide/dndkit.avif)
* **「デザインが決まっていないNext.jsプロジェクトの正解」**
* **選定理由 (拡張性):** 現在デザインが未定の状態で最も安全な選択です。デザイナーが後で「アイテムを半透明にしてほしい」、「グリッドに変えてほしい」、「ハンドルだけ掴んでドラッグできるようにしてほしい」と言っても、コードを覆さずにスタイルだけ修正して対応可能です。
* **Next.js互換性:** サーバーコンポーネント時代に合わせて設計されたモダンライブラリなので、SSRの課題処理（Hydration）が最も綺麗です。
* **短所:** 何でもカスタムできる分、初期設定コードが少し長いです。しかし、自由度のための選択だと見ることができます。

#### 🥈 2位：@formkit/drag-and-drop
https://drag-and-drop.formkit.com/
* **「機能が単純で、パフォーマンスが最優先なら」**
* **特徴:** `dnd-kit`の1/3レベルで非常に軽く、hook一行で終わるため生産性が非常に高いです。
* **脱落理由:** デザインカスタムの自由度が低いです。ブラウザ標準のドラッグ機能（Native API）を使用するため、ドラッグ時についてくる「スクリーンショット（Ghost Image）」をCSSで制御できません。後でデザイナーが複雑なインタラクションを要求したら、ライブラリを交換しなければならない可能性があります。

#### 🥉 3位：hello-pangea/dnd
https://github.com/hello-pangea/dnd?tab=readme-ov-file
* **「昔ながらの感性が必要なら」**
![](https://user-images.githubusercontent.com/2182637/53614150-efbed780-3c2c-11e9-9204-a5d2e746faca.gif)
* **特徴:** Atlassianの`react-beautiful-dnd`の継承作であり、jiraと同じようなデザインです。インストールするだけで動きがとても滑らかで綺麗です。（物理エンジン内蔵）
* **脱落理由:** 構造が古いです。バンドルサイズが重く、リスト以外の形態に拡張するのが非常に難しいです。技術的負債になる可能性があると考えました。

> **💡 技術ノート：Headless vs Native（ミールキット vs お弁当）**
>
> * **Native (@formkit など) = 完成品のお弁当:** 電子レンジで温めれば終わりなので楽ですが、「おかずがしょっぱいので薄味にしてください」のようなカスタムが不可能です。ブラウザが提供する通りに使わなければなりません。
> * **Headless (dnd-kit) = 下ごしらえ済みのミールキット:** 料理（実装）は自分でしなければなりませんが、味を整えたり盛り付け（デザイン）を自分のプロジェクトスタイルに合わせて完璧に行うことができます。CSSを一つも提供せず座標値（`transform`）だけ提供するため、`DragOverlay`を利用して自分が望むどんな形でも作ることができます。

---

## 最終結論

結果表だけ見ると、偶然にも各分野でシェア1位のライブラリがすべて選定されました。しかし、単に人気だからではなく、現在のプロジェクトが置かれた状況と制約条件を解決できる最適なツールだったからです。

### 状況に応じた意思決定

今回のライブラリ選定過程で直面した核心的な制約事項は大きく二つでした。

**1. 不確実性 → 柔軟さで対応 (Chart, DnD)**
* **状況:** チャートとDnDは企画段階でデザインや仕様が100%確定していませんでした。フロントエンド開発者である私がまずUIを提案しなければならなかったり、開発途中でデザインが変更される可能性が非常に高い状態でした。
* **決定:** 完成したデザインを提供するライブラリよりは、初期設定が面倒でも**Headless(dnd-kit)** や **コンポーネント組み立て方式(Recharts)** のように、コードを通じてカスタムできる拡張性に高い点数を与えました。

**2. リソース制約 → 生産性で対応 (Calendar)**
* **状況:** カレンダー機能はリリースまでの期限が非常に切迫していました。複雑なカスタムよりは速くて安定的な実装が最優先でした。
* **決定:** 別途ロジック実装なしでインストール後すぐに要求事項（Input + Popover）を満たせる、生産性と安定性が検証されたライブラリ（react-datepicker）を選択してリスクを減らしました。

### ライブラリを選ぶ基準

私たちはしばしば「最近何が人気？」という質問で技術導入を始めがちです。しかし今回の経験を通じて、ライブラリ選定は単純なショッピングではなく、未来の技術的負債を管理する最初の段階であることを再確認しました。良いライブラリを選定する基準は「他人が多く使っているもの」ではなく、**「自分（チーム）が扱いきれるもの」** であるべきです。

* 私たちのチームが耐えうる複雑度はどこまでか？（カスタム難易度）
* 現在の開発速度が重要か、未来の保守が重要か？（Trade-off）
* 要求事項が変わった時に柔軟に対処できるか？（拡張性）

結局、完璧な正解がない分、現在のプロジェクトの状況を正確に把握し、それに合ったトレードオフを決定することがエンジニアの核心力量だと思います。

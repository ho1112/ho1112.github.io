---
title: '라이브러리 도입기: 차트, 달력, DnD 구현을 위한 고민들'
desc: React 프로젝트를 위한 라이브러리 도입기. Recharts, react-datepicker, dnd-kit을 최종 선정한 이유와 후보군 비교 분석. 단순히 인기가 아닌 프로젝트 상황에 맞춘 기술 선정 기준을 정리했습니다.
date: 2026-01-01
thumbnail: /posts/workLog/reactLibrarySelectionGuide/thumbnail.avif
---

## 라이브러리 도입기: 차트, 달력, 그리고 DnD 기능

개발을 하다 보면 수많은 라이브러리 중에서 하나를 골라야 하는 순간이 옵니다. 단순히 "Star가 많아서", "요즘 핫해서"라는 이유로 선택하면 나중에 반드시 기술 부채로 돌아오기 마련입니다.

이번 포스팅에서는 최근 프로젝트를 진행하며 **차트(Chart), 달력(Calendar), 드래그 앤 드롭(DnD)** 기능을 구현하기 위해 검토했던 라이브러리 후보군들과 **각 후보를 1위부터 하위권까지 나눈 구체적인 이유**, 그리고 최종 결정의 근거를 정리해 보았습니다.

---

## 1. 차트(Chart) 라이브러리
디자이너가 요구한 것은 서로 다른 지표를 바 그래프와 꺾은선 그래프 2개로 보여주는 대시보드 화면이었습니다. 그래서 현재 가장 많이 사용되는 라이브러리, 유지보수 현황, 그리고 새로 추가할 기능 구현을 만족할 수 있는지를 고려해 3가지 후보를 선정했습니다.

차트 라이브러리의 세계에서는 **렌더링 방식(SVG vs Canvas)** 과 **작성 방식(컴포넌트 vs 설정객체)** 이 핵심 비교 포인트가 됩니다.

![npm trend](/posts/workLog/reactLibrarySelectionGuide/chart.avif)

### 📊 React 차트 라이브러리 종합 평가

| 평가 항목 | 가중치 | **1. Recharts** | **2. Chart.js** | **3. Nivo** |
| :--- | :--- | :--- | :--- | :--- |
| **React 친화성 (DX)** | High | **5.0 (완벽한 JSX)** | 3.5 (Wrapper 필요) | 4.5 (컴포넌트) |
| **커스텀 (유연성)** | High | **5.0 (조립식)** | 3.0 (설정 객체) | 4.5 (복잡함) |
| **퍼포먼스 (대용량)** | Mid | 3.0 (DOM 부하) | **5.0 (Canvas)** | 3.0 (SVG 위주) |
| **Next.js 호환성** | Mid | 4.0 (Dynamic 필요) | 4.0 (Dynamic) | 5.0 (SSR 지원) |
| **총점** | - | **🥇 26.5** | **🥈 24.0** | **🥉 21.5** |

### 상세 분석 및 선정 사유

#### 🥇 1위: Recharts (최종 선정)
https://recharts.github.io/en-US/
![](/posts/workLog/reactLibrarySelectionGuide/recharts.avif)
* **React 개발자가 가장 편안함을 느끼는 '레고 블록' 방식**
* **선정 이유 (React 친화성):** `<Bar />`, `<Tooltip />` 처럼 컴포넌트를 JSX 안에 툭툭 던져 놓으면 조립되는 선언적(Declarative) 방식입니다. React 개발자라면 설명서를 안 봐도 대충 어떻게 쓸지 감이 올 정도로 직관적입니다.
* **커스텀 유연성:** 툴팁을 커스텀하고 싶으면 `content={<MyCustomTooltip />}` 처럼 내가 만든 컴포넌트를 끼워 넣으면 됩니다. CSS-in-JS나 Tailwind와의 궁합이 최상입니다.
* **단점:** 데이터가 수천 개(예: 주식 틱 데이터 10년 치)가 넘어가면 브라우저가 버벅거릴 가능성이 있습니다. (SVG 렌더링의 한계) 하지만 일반적인 대시보드 수준에서는 전혀 문제없다고 생각했습니다.

#### 🥈 2위: Chart.js (react-chartjs-2)
https://www.chartjs.org/
![](/posts/workLog/reactLibrarySelectionGuide/chart.js.avif)
* **퍼포먼스가 생명이고 표준 디자인만 써도 된다면**
* **특징:** Canvas 기술을 써서 그림을 한 장의 이미지처럼 그려냅니다. 대용량 데이터 처리에 강합니다.
* **탈락 사유:** 거대한 `options` 객체 하나로 모든 걸 제어해야 합니다. "축 색깔을 바꾸려면 `scales.y.grid.color`를 찾아가야 하나?" 처럼 옵션 찾기 게임을 해야 합니다. 툴팁 안에 복잡한 HTML/CSS 디자인을 넣으려면 별도의 플러그인을 짜거나 캔버스를 직접 건드려야 해서 난이도가 급상승합니다. 사양변경과 유지보수가 어려울 거라 생각했습니다.

#### 🥉 3위: Nivo
https://nivo.rocks/
![](/posts/workLog/reactLibrarySelectionGuide/nivo.avif)
* **화려한 디자인의 차트가 필요하다면**
* **특징:** 설치하자마자 디자이너가 디자인한 것 같은 예쁜 차트와 화려한 애니메이션이 나옵니다. D3.js를 React로 잘 감싸놓은 형태입니다.
* **탈락 사유:** 한마디로 투머치(Too Much)였습니다. Props가 너무 많아서 간단한 막대그래프 하나 그리는데도 설정할 게 많습니다. 단순한 현재 서비스의 대시보드용으로는 오버스펙이라고 생각했습니다.

> **💡 기술 노트: SVG vs Canvas**
> * **SVG (Recharts, Nivo) = HTML 태그 (DOM):** 막대 하나하나가 `<div>`나 `<path>` 태그입니다. 개발자 도구로 찍어볼 수 있고 CSS 호버 효과 주기가 쉽습니다. 대신 태그가 많아지면 느려집니다.
> * **Canvas (Chart.js) = 그림 (Image):** 도화지 한 장에 픽셀로 그립니다. 데이터가 많아도 빠르지만, 이미 그려진 그림의 특정 부분만 스타일을 바꾸거나 이벤트를 걸기가 매우 까다롭습니다.

Recharts로 실제 개발에 착수하여 구현한 초기 단계의 스크린샷입니다. (최종 릴리스 버전과는 차이가 있습니다)
<div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap', justifyContent: 'center', margin: '24px 0' }}>
  <img
    src="/posts/workLog/reactLibrarySelectionGuide/bar.avif"
    style={{
      maxWidth: '100%',
      height: 'auto',
      flex: '1',
      minWidth: '300px',
      borderRadius: '8px',
      boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
    }}
  />
  <img
    src="/posts/workLog/reactLibrarySelectionGuide/line.avif"
    style={{
      maxWidth: '100%',
      height: 'auto',
      flex: '1',
      minWidth: '300px',
      borderRadius: '8px',
      boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
    }}
  />
</div>

---

## 2. 달력(Calendar) 라이브러리
요구사항은 아래와 같았습니다.
1. 단일 날짜 선택
2. 월별 이동
3. 대상이 아닌 날짜는 disabled, 지난달과 다음달의 날짜는 비표시
4. 디자인의 커스터마이징이 가능할 것

그리고 릴리스 목표까지 기한이 촉박해 개발 공수를 줄여야 했습니다. 따라서 인풋 창을 누르면 달력이 뜨는(Input + Popover) 기능이 필수였습니다. 이를 만족하는 4가지 후보군을 비교했습니다.

![npm trend](/posts/workLog/reactLibrarySelectionGuide/calendar.avif)

### 🗓️ 캘린더 라이브러리 종합 평가

| 평가 항목 | 가중치 | **1. react-datepicker** | **2. react-date-picker** | **3. react-datetime** | **4. react-dates** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **안정성/인지도** | Max | **5.0 (압도적 1위)** | 3.0 (이름 혼동) | 3.0 (감소세) | 3.5 (관리 중단) |
| **기능 (Input+Popover)** | Max | **5.0 (내장됨)** | 4.0 (투박함) | 3.0 (시간 특화) | 2.0 (Range 특화) |
| **커스텀 용이성** | Mid | 4.0 (CSS 덮어쓰기) | 3.5 (까다로움) | 3.0 (Old Style) | 2.0 (매우 어려움) |
| **번들 사이즈** | Mid | 4.0 (적당) | 4.0 (적당) | 3.0 (의존성) | 1.0 (매우 무거움) |
| **총점** | - | **🥇 18.0** | **🥈 14.5** | **12.0** | **8.5** |

### 상세 분석 및 선정 사유

#### 🥇 1위: react-datepicker (최종 선정)
https://reactdatepicker.com/
![](/posts/workLog/reactLibrarySelectionGuide/react-datepicker.avif)
* **"사실상의 업계 표준(De Facto Standard). 가장 안전하고 빠른 길"**
* **선정 이유:** npm 다운로드 수가 압도적이라 버그 발생 시 레퍼런스(StackOverflow 등)를 찾기가 가장 쉽습니다. 우리가 필요한 'Input + Popover' 형태를 기본으로 제공하여 별도의 포털(Portal) 로직을 짤 필요가 없습니다. CSS 클래스 구조가 명확해 디자인 덮어쓰기도 용이했습니다.

#### 🥈 2위: react-date-picker (유사품 주의)
https://github.com/wojtekmaj/react-date-picker#readme
* **"나쁘지 않지만 굳이 2등을 쓸 이유는 없다"**
* **특징:** `react-calendar`를 기반으로 만들어진 라이브러리입니다.
* **탈락 사유:** 1위인 `react-datepicker`와 이름이 거의 같아 혼동하기 쉽지만 사용자 수가 훨씬 적습니다. 기능적으로 큰 차별점이 없는데 커뮤니티 지원이 약한 라이브러리를 선택하여 모험을 할 필요가 없다고 판단했습니다.

#### 🥉 3위: react-datetime
https://github.com/arqex/react-datetime
* **"시간(Time) 선택이 메인이라면 고려했겠지만..."**
* **특징:** 날짜와 시간을 동시에 선택하는 UI에 특화되어 있습니다.
* **탈락 사유:** 디자인이 다소 구형 스타일이며 최근 유지보수 트렌드에서 밀려나고 있습니다. '날짜'가 메인이고 시간은 별도 UI로 구현할 예정이라 목적에 맞지 않았습니다.

#### 4위: react-dates (Airbnb)
https://github.com/react-dates/react-dates/
![](https://raw.githubusercontent.com/react-dates/react-dates/HEAD/react-dates-demo.gif)
* **"호텔 예약 사이트를 만든다면 1순위였을 것"**
* **특징:** Airbnb가 만든 라이브러리로, "시작일~종료일(Range)" 선택 UI가 매우 강력합니다. 이번 기능은 단일 날짜 선택이라 종료일이 불필요했기에 우선순위에서 밀렸습니다.
* **탈락 사유:**
    1.  **Overkill (기능 과잉):** 단순 날짜 선택에는 기능이 너무 많고 복잡합니다.
    2.  **무거움:** 지금은 잘 쓰지 않는 `Moment.js`에 강한 의존성이 있어 번들 사이즈가 불필요하게 커집니다.
    3.  **유지보수:** 최근 관리가 잘 안 되고 있어 신규 프로젝트 도입에는 위험 부담이 컸습니다.

react-datepicker로 구현한 실제 서비스 완성 버전
<img src="/posts/workLog/reactLibrarySelectionGuide/calendar_sche.avif" alt="캘린더 구현" width="350" />

---

## 3. 드래그 앤 드롭(DnD) 라이브러리
가장 고민이 많았던 분야입니다. 어떤 '느낌'의 인터랙션을 원하느냐 그리고 얼마나 '커스텀' 할 것이냐에 따라 선택지가 완전히 달라지기 때문입니다.
디자이너도 어떤 방식이 가능할지 모르는 상태라 저에게 먼저 제안해달라고 했던 기능이기도 했습니다. 따라서 디자인적인 측면까지 고려해서 생각했습니다.

![npm trend](/posts/workLog/reactLibrarySelectionGuide/dnd.avif)

### 🖱️ DnD 라이브러리 종합 평가

| 평가 항목 | 가중치 | **1. dnd-kit** | **2. @formkit** | **3. hello-pangea** |
| :--- | :--- | :--- | :--- | :--- |
| **생태계 & 미래** | High | **5.0 (표준/활발)** | 3.0 (신생) | 3.5 (유지보수 위주) |
| **커스텀 (확장성)** | Max | **5.0 (Headless)** | 3.0 (Browser 의존) | 2.5 (제한적) |
| **Next.js 호환성** | High | **5.0 (완벽 지원)** | 4.5 (좋음) | 4.0 (패치 필요) |
| **번들 사이즈** | Mid | 4.0 (모듈식) | **5.0 (초경량)** | 2.0 (무거움) |
| **총점** | - | **🥇 27.0** | **🥈 23.5** | **🥉 20.0** |

### 상세 분석 및 선정 사유

#### 🥇 1위: dnd-kit (최종 선정)
https://dndkit.com/
![](/posts/workLog/reactLibrarySelectionGuide/dndkit.avif)
* **"디자인이 정해지지 않은 Next.js 프로젝트의 정답"**
* **선정 이유 (확장성):** 현재 디자인이 미정인 상태에서 가장 안전한 선택입니다. 디자이너가 나중에 "아이템을 반투명하게 해달라", "격자로 바꿔달라", "핸들만 잡고 끌게 해달라" 해도 코드를 엎지 않고 스타일만 수정해서 대응 가능합니다.
* **Next.js 호환성:** 서버 컴포넌트 시대에 맞춰 설계된 모던 라이브러리라 SSR 이슈 처리(Hydration)가 가장 깔끔합니다.
* **단점:** 뭐든지 커스텀이 가능한만큼 초기 설정 코드가 좀 깁니다. 하지만 자유도를 위한 선택이라고 볼 수 있습니다.

#### 🥈 2위: @formkit/drag-and-drop
https://drag-and-drop.formkit.com/
* **"기능이 단순하고, 퍼포먼스가 최우선이라면"**
* **특징:** `dnd-kit`의 1/3 수준으로 매우 가볍고 hook 한 줄이면 끝나서 생산성이 매우 높습니다.
* **탈락 사유:** 디자인 커스텀 자유도가 낮습니다. 브라우저 기본 드래그 기능(Native API)을 사용하기 때문에 드래그 시 따라다니는 '스크린샷(Ghost Image)'을 CSS로 제어할 수 없습니다. 나중에 디자이너가 복잡한 인터랙션을 요구하면 라이브러리를 교체해야 할 수도 있습니다.

#### 🥉 3위: hello-pangea/dnd
https://github.com/hello-pangea/dnd?tab=readme-ov-file
* **"옛날 방식의 감성이 필요하다면"**
![](https://user-images.githubusercontent.com/2182637/53614150-efbed780-3c2c-11e9-9204-a5d2e746faca.gif)
* **특징:** Atlassian의 `react-beautiful-dnd`의 계승작이라 jira와 같은 디자인입니다. 설치만 해도 움직임이 아주 부드럽고 예쁩니다. (물리 엔진 내장)
* **탈락 사유:** 구조가 낡았습니다. 번들 사이즈가 무겁고 리스트 이외의 형태로 확장하기가 매우 어렵습니다. 기술적 부채가 될 가능성이 있다고 생각했습니다.

> **💡 기술 노트: Headless vs Native (밀키트 vs 도시락)**
>
> * **Native (@formkit 등) = 완제품 도시락:** 전자레인지에 돌리면 끝이라 편하지만 "반찬이 짠데 싱겁게 해주세요" 같은 커스텀이 불가능합니다. 브라우저가 주는 대로 써야 합니다.
> * **Headless (dnd-kit) = 손질된 밀키트:** 요리(구현)는 내가 해야 하지만 간을 맞추거나 플레이팅(디자인)을 내 프로젝트 스타일에 맞춰 완벽하게 할 수 있습니다. CSS를 하나도 주지 않고 좌표값(`transform`)만 주기 때문에 `DragOverlay`를 이용해 내가 원하는 어떤 모양이든 만들 수 있습니다.

---

## 최종 결론

결과표만 놓고 보면 우연히도 각 분야에서 점유율 1위인 라이브러리들이 모두 선정되었습니다. 하지만 단순히 인기가 아니라 현재 프로젝트가 처한 상황과 제약 조건을 해결할 수 있는 최적의 도구였기 때문입니다.

### 상황에 따른 의사결정

이번 라이브러리 선정 과정에서 마주한 핵심 제약 사항은 크게 두 가지였습니다.

**1. 불확실성 → 유연함으로 대응 (Chart, DnD)**
* **상황:** 차트와 DnD는 기획 단계에서 디자인이나 사양이 100% 확정되지 않았습니다. 프론트엔드 개발자인 제가 먼저 UI를 제안해야 하거나, 개발 도중 디자인이 변경될 가능성이 매우 높은 상태였습니다.
* **결정:** 완성된 디자인을 제공하는 라이브러리보다는, 초기 설정이 번거롭더라도 **Headless(dnd-kit)** 나 **컴포넌트 조립 방식(Recharts)** 처럼 코드를 통해 커스텀할 수 있는 확장성에 높은 점수를 주었습니다.

**2. 리소스 제약 → 생산성으로 대응 (Calendar)**
* **상황:** 달력 기능은 릴리스까지의 기한이 매우 촉박했습니다. 복잡한 커스텀보다는 빠르고 안정적인 구현이 최우선이었습니다.
* **결정:** 별도의 로직 구현 없이 설치 즉시 요구사항(Input + Popover)을 만족시킬 수 있는 생산성과 안정성이 검증된 라이브러리(react-datepicker)를 선택하여 리스크를 줄였습니다.

### 라이브러리를 고르는 기준

우리는 종종 "요즘 뭐가 인기야?"라는 질문으로 기술 도입을 시작하곤 합니다. 하지만 이번 경험을 통해 라이브러리 선정은 단순한 쇼핑이 아니라 미래의 기술 부채를 관리하는 첫 번째 단계임을 다시 한번 깨달았습니다. 좋은 라이브러리를 선정하는 기준은 '남들이 많이 쓰는 것'이 아니라, **'내(팀)가 감당할 수 있는 것'** 이어야 합니다.

* 우리 팀이 감당해야 할 복잡도는 어디까지인가? (커스텀 난이도)
* 현재의 개발 속도가 중요한가, 미래의 유지보수가 중요한가? (Trade-off)
* 요구사항이 바뀌었을 때 유연하게 대처할 수 있는가? (확장성)

결국 완벽한 정답이 없는만큼 현재 프로젝트의 상황을 정확히 파악하고 그에 맞는 트레이드오프를 결정하는 것이 엔지니어의 핵심 역량이라고 생각합니다.

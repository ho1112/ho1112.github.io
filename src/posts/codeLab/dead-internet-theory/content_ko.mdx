---
title: 'Dead Internet Theory - AI 페르소나 봇 댓글 자동화 시스템 개발기'
desc: '블로그 댓글 시스템을 완전히 독립적으로 구축하고, AI 봇들이 자연스러운 대화를 통해 댓글을 생성하는 "Dead Internet Theory"를 구현한 프로젝트입니다.'
date: 2025-09-08
thumbnail: /posts/codeLab/dead-internet-theory/thumbnail.avif
---

# Dead Internet Theory - AI 페르소나 봇 댓글 자동화 시스템 개발기

## 1. 개요
솔직히 제 블로그 댓글창은 거의 '개점휴업' 상태였습니다. 가끔 혼잣말하는 기분이 들 때쯤 흥미로운 가설 하나를 알게 됐습니다. 바로 죽은 인터넷 이론(dead internet theory)입니다.

**죽은 인터넷 이론**이란 우리가 보는 웹의 대부분이 실제 사람이 아닌 AI 봇이 생성한 콘텐츠로 채워져 있다는 조금은 섬뜩한 가설입니다. (최근 유튜브에도 다른 사람의 댓글을 그대로 따라하거나 아무 댓글이 없는데 리액션을 남발하는 댓글들을 보신 적 있으신가요..? 👿)

"어쩌면 미래엔 정말 이렇게 될지도?" 하는 호기심에 곧장 만들어보고 싶었습니다. 썰렁한 댓글창을 개성 넘치는 AI 페르소나 봇 친구들로 북적거리게 만드는 동시에 이참에 외부 서비스(Giscus) 의존성까지 끊어내서 저만의 독립적인 댓글 시스템을 만들기로 했습니다.

모든 글이 봇으로 가득차면 그건 그거대로 무서울 거 같아서 우선은 weekly 뉴스레터 정리하는 게시글에만 적용할 생각입니다. 나머지 글은 저의 개인적인 생각이 담기는거라 AI의 다양한 관점까지는 없어도 될 거 같기도 해서요.

---

## 2. 기술 스택

### Frontend
- **Next.js**
- **TypeScript**
- **Tailwind CSS**
- **React Query**

### Backend
- **Supabase**
- **Google Gemini 2.5 Pro**

### Deployment & Automation
- **Vercel**
- **GitHub Actions** - Cron Job 자동화 (5분마다 실행하도록 설정)
- **GitHub Webhook** - 새 포스트 감지 및 자동 트리거

---

## 3. 주요 기능

### 1. AI 페르소나 시스템
- 4개의 개성 있는 AI 봇 (한국어/일본어 지원)
- 각각 다른 성격과 말투로 댓글 생성
- 자연스러운 대화 흐름 유지

#### Heisenbug
<img src="https://dead-internet-theory-sigma.vercel.app/personal/Heisenbug.svg" alt="하이젠버그" width="75" />
현실주의 시니어 개발자. 이론보다 실제 프로덕션 환경에서의 안정성과 효율성을 중시하는 비판적 전문가
반말어투로 감정보다는 논리를 우선시합니다. 날카로운 말투로 대댓글을 통한 토론 분위기를 이끌어 내는 트리거 역할을 위해 만들었습니다.
<img src="/posts/codeLab/dead-internet-theory/하이젠버그.jpeg" alt="하이젠버그" width="75" style={{ display: 'block', margin: '0 auto'}}/>
<small>이름은 디버깅을 하려고 하면 버그가 사라지는 현상을 말하는 하이젠버그라는 단어에서 따왔습니다. 어원이 되는 불확정성의 원리 하이젠베르크(Heisenberg)와 동명인 드라마 브레이킹베드의 주인공 캐릭터에서 성격과 아바타 이미지를 차용했습니다</small>
#### 특이점은온다
<img src="https://api.dicebear.com/9.x/open-peeps/svg?seed=Katherine&accessories=eyepatch&face=explaining&facialHair=moustache2,moustache3&facialHairProbability=5&head=noHair1&headContrastColor[]&mask[]&skinColor=edb98a,ffdbb4&backgroundColor=c0aede" alt="특이점은은다" width="75" />
이상주의 개발자. 최신기술과 트렌드, AI에 열광합니다. Heisenbug와는 반대되는 캐릭터입니다.
포스트에 대한 리액션을 담당하고 긍정적인 의견을 제시할 수 있도록 설계했습니다.
닉네임은 미래학자 레이 커즈와일의 저서 '특이점은 온다(The Singularity Is Near)'에서 가져왔습니다.
#### wow!
<img src="https://api.dicebear.com/9.x/fun-emoji/svg?seed=Katherine" alt="wow!" width="75" />
대규모 서비스를 기획/운영하는 프로덕트 매니저(PdM). 기술보다는 그것으로 무엇을 할 수 있는지와 같은 사업적 가치를 중시합니다.
개발자가 아닌 참신한 시각으로 의견을 제시할 수 있도록 설계했습니다.
#### tora
<img src="https://api.dicebear.com/9.x/thumbs/svg?seed=Mason&backgroundColor=transparent&eyes=variant4W10,variant4W12,variant4W14,variant4W16,variant5W10,variant5W12,variant5W14,variant5W16,variant6W10,variant6W12,variant6W14,variant6W16,variant7W10,variant8W10,variant8W12,variant8W14,variant8W16&eyesColor=ffffff&mouth=variant1,variant2&mouthColor=ffffff&shapeColor=f88c49,f1f4dc,69d2e7,1c799f,0a5b83,transparent" alt="tora" width="75" />
토론의 맥락을 파괴하는 와일드카드. 분위기를 환기하거나, 예상치 못한 유머를 제공합니다.
하이젠버그 캐릭터가 너무 강해서 분위기 환기를 위해 만들었습니다. 과열된 분위기를 식히고 중재하도록 만들었습니다. 언제나 가벼운 말투를 사용하지만 가끔은 모든 의견을 종합해 결론을 내버리는 의외성도 갖추도록 만들었습니다.

### 2. 지능적 댓글 생성
- 기존 댓글 맥락 분석
- 대댓글/새 댓글 자동 판단
- 1분~3시간 랜덤 지연으로 자연스러운 타이밍

### 3. 완전 자동화 시스템
- 새 포스트 감지 시 자동 웹훅 호출
- GitHub Actions Cron으로 24시간 자동 실행
- 연쇄적 댓글 생성 (최대 20개까지 설정)

### 4. 관리자 대시보드
- 댓글 관리 및 통계
- 포스트별 댓글 현황
- AI 봇 수동 트리거 및 삭제 기능

![댓글관리 - 삭제기능](/posts/codeLab/dead-internet-theory/dash_comment.avif)
![포스트 목록 - 수동 트리거](/posts/codeLab/dead-internet-theory/dash_posts.avif)

---

## 4. 기능 구현

### AI 봇 디렉터 시스템
페르소나 봇의 설정과 블로그 포스트, 댓글 현황을 모두 AI에게 공유하여 AI가 자율적으로 댓글을 생성하도록 했습니다.
이 과정에서 별도의 분기처리, 로직이 들어가지 않기 때문에 AI의 외외성이 극대화 될 거라고 생각했습니다.

### 2. 지능적 대화 분석 시스템

AI가 기존 댓글들의 맥락을 분석하여 자연스러운 대화 흐름을 유지하도록 구현했습니다.

```typescript
// 대화 구조 분석 함수
function analyzeConversationStructure(comments: Comment[]): string {
  if (comments.length === 0) {
    return '새로운 포스트입니다. 첫 댓글을 작성할 차례입니다.';
  }

  const parentComments = comments.filter(c => !c.parent_id);
  const replyComments = comments.filter(c => c.parent_id);
  const maxDepth = Math.max(...comments.map(c => {
    let depth = 0;
    let current = c;
    while (current.parent_id) {
      depth++;
      current = comments.find(cc => cc.id === current.parent_id) || current;
      if (depth > 10) break; // 무한 루프 방지
    }
    return depth;
  }));

  let analysis = `대화 현황: ${parentComments.length}개 메인 댓글, ${replyComments.length}개 대댓글\n`;
  analysis += `대화 깊이: 최대 ${maxDepth}단계\n`;

  // 대화 상황에 따른 전략 제시
  if (replyComments.length > 0) {
    analysis += '대화가 활발하게 진행되고 있습니다. 적절한 대댓글이나 새로운 관점의 댓글이 도움이 될 수 있습니다.\n';
  } else if (parentComments.length >= 2) {
    analysis += '여러 메인 댓글이 있지만 대화가 깊어지지 않았습니다. 대화를 이끌어갈 수 있는 댓글이 필요합니다.\n';
  } else {
    analysis += '아직 대화 초기 단계입니다. 포스트 내용에 대한 다양한 관점의 댓글이 도움이 될 수 있습니다.\n';
  }

  return analysis;
}
```

### 3. GitHub Actions Cron Job 시간차 댓글 시스템

봇 활동을 자연스럽게 숨기기 위해 1분~3시간의 랜덤 지연을 구현했습니다. 이는 "Dead Internet Theory"의 핵심인 예측할 수 없는 자율성을 구현하는 중요한 기능입니다.
저조차도 직접 DB를 확인하지 않으면 언제 댓글이 달릴지 알 수가 없습니다.

```yaml
# .github/workflows/bot-cron.yml
name: Bot Comment Cron Job
on:
  schedule:
    - cron: '*/5 * * * *'  # 5분마다 실행
  workflow_dispatch:  # 수동 실행 가능

jobs:
  process-scheduled-jobs:
    runs-on: ubuntu-latest
    steps:
      - name: Process Scheduled Bot Comments
        run: |
          curl -X GET "${{ secrets.VERCEL_URL }}/api/cron/process-scheduled-jobs"
```

```typescript
// 웹훅에서 랜덤 지연 시간 계산
const delayMinutes = Math.floor(Math.random() * (180 - 1 + 1)) + 1; // 1~180분
const delayMs = delayMinutes * 60 * 1000;
const executionTime = new Date(Date.now() + delayMs);

// scheduled_jobs 테이블에 예약 저장
const { data: scheduledJob, error: saveError } = await supabase
  .from(tableNames.scheduledJobs || 'scheduled_jobs')
  .insert({
    id: crypto.randomUUID(),
    post_id,
    url,
    execution_time: executionTime.toISOString(),
    status: 'pending',
    created_at: new Date().toISOString()
  });
```

### 4. 자동화 시스템 아키텍처
<img src="/posts/codeLab/dead-internet-theory/archi_ko.svg" alt="아키텍처 다이어그램" width="250" />
**DB**
<img src="/posts/codeLab/dead-internet-theory/table.svg" alt="DB" width="700" />


### 5. 프롬프트 엔지니어링 최적화

AI가 정확한 응답을 생성하도록 구조화된 프롬프트를 설계했습니다.

```typescript
const prompt = `
당신은 블로그 포스트에 댓글을 달 AI 페르소나입니다.

상황 정보
포스트 ID: ${postId}
포스트 언어: ${postLanguage}

포스트 본문:
${postContent}

전체 댓글들:
${existingComments.map(c => `- ID: ${c.id} | ${c.author_name} (${c.is_bot ? 'AI봇' : '사람'})${c.parent_id ? ' [대댓글]' : ''}: ${c.content}`).join('\n')}

대화 구조 분석
${analyzeConversationStructure(existingComments)}

선택 가능한 페르소나들 (${postLanguage} 언어)
${personas.map((p, index) => `${index + 1}. ${p.nickname}: ${p.system_prompt}`).join('\n\n')}

답변 형식:
선택된 페르소나: [페르소나명]
선택 이유: [왜 이 페르소나를 선택했는지]
댓글 타입: [new_comment 또는 reply]
대댓글 대상 ID: [reply인 경우 반응할 댓글의 ID, new_comment인 경우 비워두기]
대댓글 대상 닉네임: [reply인 경우 반응할 댓글의 작성자 닉네임, new_comment인 경우 비워두기]
댓글: [실제 댓글 내용]`;
```

---

## 5. 성과

### 정량적 지표
- **4개 AI 페르소나** 구현 (한국어/일본어 각각)
- **최대 20개** 연쇄 댓글 자동 생성
- **5분마다** 자동 실행되는 Cron Job

### 기술적 성과
- **단일 AI 호출 모델**로 복잡성 감소
- **GitHub Actions** 기반 완전 자동화
- **랜덤 지연 시스템**으로 자연스러운 봇 활동 구현

---

## 6. 인사이트

### 배운 점
1. **AI 프롬프트 엔지니어링의 중요성**: 구조화된 응답 형식으로 파싱 오류를 크게 줄일 수 있었습니다.
2. **환경별 분리 설계의 필요성**: `dev_` 접두사로 개발/운영 데이터를 완전 분리하여 안전한 테스트 환경을 구축했습니다.
3. **자동화 시스템의 복잡성**: 단순해 보이는 자동화도 웹훅, Cron Job, 데이터베이스 상태 관리 등 여러 요소가 복합적으로 작동합니다.
4. **개발자의 보람과 의욕상승**: 포스트를 작성하고 하루 뒤, 댓글 창에 가득한 페르소나 댓글들을 보고 나면 더 많은 컨텐츠를 개발하고 싶어집니다.

### 아쉬운 점과 개선 방향
- **댓글 길이**: 1000자의 제한을 두었더니 1000자에 가까운 댓글만 생성. 사람처럼 짧은 댓글, 대댓글로 토론 분위기가 형성 됐을 때만 길게 작성하도록 세심한 프롬프트 설계 필요
- **봇 댓글의 다양성**: 더 많은 페르소나를 생성하여 더 재밌는 댓글과 상황이 나올 수 있게 설계

#### ↓ 이 아래에 댓글에서 결과를 확인할 수 있습니다. 실제 페르소나 봇들은 자신들에 대해 설명한 이 글에 대해 어떤 반응을 보일까요? 🫨

---

### 2025년 12월 20일 추가대응
Google AI Studio의 정책 변경으로 무료 api 사용이 제한되었습니다. 기존의 2.5-pro 모델사용이 제한되어 댓글 생성이 실패하고 있었습니다.
api 요청 방식도 변경되었기 때문에 함께 대응 했습니다.

기존: fetch 방식, 2.5-pro모델 사용
```typescript
    // 3. Gemini API 호출
    const response = await fetch(`https://generativelanguage.googleapis.com/v1/models/gemini-2.5-pro:generateContent?key=${process.env.GEMINI_API_KEY}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }]
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API 호출 실패: ${response.status}`);
    }

    const data = await response.json();
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
```

수정: @google/genai 인증방식으로 변경, 3.0 flash모델로 변경
```typescript
import { GoogleGenAI } from '@google/genai';

   // 3. Gemini API 호출 (새로운 SDK 사용)
    const ai = new GoogleGenAI({
      apiKey: process.env.GEMINI_API_KEY
    });

    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: prompt
    });

    const generatedText = response.text;
```
[변경 PR](https://github.com/ho1112/dead-internet-theory/pull/14/files)

<Callout type="info" title="개인 프로젝트 포스트">
[cha-LINE](/blog/ko/codeLab/cha-line/) - SBI 증권 배당금 자동 수집 및 LINE 알림 봇
[its-me](/blog/ko/codeLab/its-me) - AI 기반 RAG 인터랙티브 포트폴리오 챗봇
[Style Sentry](/blog/ko/codeLab/style-sentry) - CSS 코드 품질을 지키는 린터 도구
</Callout>

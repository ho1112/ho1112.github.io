---
title: 'Style Sentry 개발기: 팀의 CSS 코드 품질을 지키는 린터 도구 만들기'
desc: 'CSS 코드 품질을 자동으로 검증하는 린터 도구 Style Sentry의 개발 과정과 기술적 구현 방법을 소개합니다.'
date: 2025-09-07
thumbnail: /posts/codeLab/style-sentry/thumbnail.avif
---

# Style Sentry 개발기: 팀의 CSS 코드 품질을 지키는 린터 도구 만들기

## 1. 개요

프론트엔드 개발을 하다 보면 항상 마주치는 문제가 있습니다. **"이 CSS 클래스가 정말 사용되고 있을까?"**

팀 프로젝트에서 CSS 파일이 점점 커지면서 미사용 클래스들이 쌓이고 가독성은 떨어져갔습니다. 매번 수동으로 확인하기엔 시간이 부족했고 코드 리뷰에서도 놓치는 경우가 많았죠.

그래서 CSS 코드 품질을 자동으로 검증하는 도구를 만들어보기로 했습니다. 단순한 린터가 아닌 팀의 코딩 스탠다드를 강제할 수 있는 도구를 목표로 했습니다.

## 2. 기술스택

### Backend (CLI 도구)
- **Node.js 18+**
- **JavaScript**
- **PostCSS**
- **Babel Parser** - JSX/TSX 파일의 정확한 AST 분석
- **Commander.js** - CLI 인터페이스

### VSCode Extension
- **TypeScript**
- **VSCode Extension API**
- **vsce** - 확장 프로그램 패키징 및 배포

### 선택 이유
PostCSS를 선택한 이유는 CSS 전처리기(SCSS, Less)를 통합적으로 처리할 수 있기 때문입니다. Babel Parser는 JSX의 복잡한 문법을 정확히 파싱하기 위해 선택했습니다.
npm 패키지로 시작한 프로젝트였지만 개발자가 경고를 실시간으로 확인하며 즉각적으로 대응할 수 있을 때 가장 큰 효용을 낼 수 있다고 생각했습니다. 그래서 목표를 확장하여 VSCode 확장 프로그램까지 개발하게 되었습니다.

## 3. 주요기능

### 핵심 기능 3가지
1. **미사용 CSS 클래스 검출** - JSX/TSX에서 실제 사용되지 않는 클래스 자동 발견
2. **디자인 시스템 색상 검증** - 허용된 색상만 사용하는지 확인
3. **숫자 속성 제한 검사** - z-index, font-size 등의 임의 값 사용 방지

### 특별한 기능
- **동적 클래스 접근 패턴 인식** - `styles[className]` 같은 동적 접근도 감지
- **classnames 라이브러리 지원** - `cn()`, `classNames()`, `clsx()` 함수 완벽 지원
- **TypeScript/webpack 별칭 경로 해석** - `@styles/` 같은 경로 자동 매핑
- **SCSS 믹스인 내부 중첩 클래스 지원** - `&.oval`, `&.round` 같은 패턴 지원

## 4. 기능구현

### 가장 도전적이었던 부분: 동적 클래스 접근 감지의 진화

**v1.0 초기 버전의 문제점:**
```javascript
// 이런 패턴을 어떻게 감지할까?
className={`${styles.button} ${styles[buttonType]}`}
```

**v1.1 개선: 동적 접근이 감지된 부모의 자식만 제외**
```javascript
// AST 트래버싱으로 동적 접근 패턴 분석
traverse(ast, {
  JSXAttribute: ({ node }) => {
    if (node.name.name === 'className') {
      function walk(expr) {
        if (expr.type === 'MemberExpression' && expr.computed) {
          // styles[variable] 패턴 감지
          foundDynamicParents.add(parentClass);
        }
      }
    }
  }
});
```

**v1.3 최종 완성: SCSS 믹스인까지 지원**
```javascript
// SCSS 믹스인에서 중첩 클래스 추출
function extractMixinNestedClasses(root) {
  root.walkAtRules('mixin', mixinRule => {
    mixinRule.walkRules(nestedRule => {
      if (selector.startsWith('&.')) {
        const nestedClass = selector.slice(2); // &.oval → oval
        parentToChildren.get(parentClass).add(nestedClass);
      }
    });
  });
}
```

### classnames 라이브러리 지원 구현

**문제 상황:** 현업에서 `cn(styles.content, styles[status])` 같은 패턴이 감지되지 않음

**해결 과정:**
```javascript
// CallExpression 노드 처리 추가
if (expr.type === 'CallExpression') {
  if (expr.callee.name === 'cn' || expr.callee.name === 'classNames' || expr.callee.name === 'clsx') {
    expr.arguments.forEach(arg => walk(arg, lastStatic));
  }
}
```

**지원하는 복잡한 패턴:**
```javascript
cn(styles.container, styles[status], { [styles.active]: isActive })
cn(styles.button, styles[`button-${size}`])
```

### TypeScript/Webpack Alias 자동 해석

**문제 상황:** `import styles from '@styles/setting_ats.module.scss'` 같은 alias 경로를 인식하지 못함

**해결 과정:**
```javascript
function detectPathAliases() {
  // 1. tsconfig.json의 paths 감지
  const tsconfigPath = path.resolve(process.cwd(), 'tsconfig.json');
  if (fs.existsSync(tsconfigPath)) {
    const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));
    if (tsconfig.compilerOptions && tsconfig.compilerOptions.paths) {
      Object.entries(tsconfig.compilerOptions.paths).forEach(([pattern, paths]) => {
        const alias = pattern.replace('/*', '');
        const aliasPath = paths[0].replace('/*', '');
        aliases[alias] = aliasPath;
      });
    }
  }

  // 2. webpack.config.js의 alias 감지
  // 3. package.json의 imports 감지
}
```

### 아키텍처 다이어그램
<img src="/posts/codeLab/style-sentry/architecture_ko.svg" alt="아키텍처 다이어그램" width="500" />

### 실제 테스트 케이스들

**테스트 파일 구성:**
- `test/cn-test.jsx` - classnames 라이브러리 테스트
- `test/button-test.module.scss` - SCSS 믹스인 테스트
- `test/alias-test.jsx` - alias 경로 테스트
- `test/tsconfig.json` - alias 설정 테스트용

**테스트 시나리오:**
```javascript
// 동적 접근 테스트
<button className={cn(styles.button, styles[buttonType])} />

// SCSS 믹스인 테스트
@mixin button {
  &.oval { border-radius: 50%; }
  &.round { border-radius: 8px; }
}
```

### vscode settings에서 각 옵션 제어
![](/posts/codeLab/style-sentry/style-sentry_settings.webp)


## 5. 성과

### 정량적 성과
- **처리 속도**: 현업 프로젝트의 수십개 파일 3초내 체크 완료
- **정확도**: 동적 클래스 접근 패턴 정확 감지
- **지원 범위**: CSS, SCSS, Less, JSX, TSX 파일 완벽 지원

### 정성적 성과
- **팀 멤버 공유**: 완성된 후 미팅 시간에 **기습** 공유
- **코드 품질**: 미사용 CSS 클래스 자동 발견 및 정리, 실시간 감지 가능
- **일관성**: 디자인 시스템 색상 사용률 100% 달성

### 기술적 성과
- **npm 패키지 등록**: https://www.npmjs.com/package/style-sentry
- **VSCode 마켓플레이스 등록**: https://marketplace.visualstudio.com/items?itemName=leehoyeon.style-sentry-vscode
- **확장성**: 새로운 린팅 규칙 추가 용이한 구조 설계

### 실제 프로젝트 내에서
![npm커맨드로 실행](/posts/codeLab/style-sentry/npx.avif)
![scss에서 미사용 클래스 경고 표시](/posts/codeLab/style-sentry/scss.avif)

![](/posts/codeLab/style-sentry/team3.svg)
![](/posts/codeLab/style-sentry/team2.svg)
![생산성향상 미팅 시간에 공유해보았습니다](/posts/codeLab/style-sentry/team1.svg)

## 6. 인사이트

### 배운 점
1. **AST 분석의 중요성**: 단순 문자열 매칭이 아닌 구문 분석의 정확성
2. **사용자 경험 고려**: 개발자가 실제로 사용하기 편한 인터페이스 설계
3. **확장성 있는 아키텍처**: 새로운 규칙 추가가 쉬운 플러그인 구조
4. **실무 환경 대응의 중요성**: 믹스인과 alias는 현업에서 매우 일반적으로 사용되는 패턴
5. **정적 분석의 현실적 한계**: 완벽한 추적은 어려우므로 사용자에게 명확한 한계 안내 필요

### 발견된 제한사항
- **컴포넌트 기반 사용**: `&.icon i` 같은 클래스가 `<Icon>` 컴포넌트 내부에서 사용되지만 린터가 감지하지 못함
- **동적 렌더링**: 조건부 렌더링이나 동적 컴포넌트에서 사용되는 클래스 감지 불가
- **CSS-in-JS**: styled-components 등에서 정의된 클래스 미지원
- **오탐지**: 타이밍에 따라 실제 사용되는 클래스가 미사용으로 표시될 수 있음, 파일을 새로 열고 닫으면 다시 정상 감지

### 아쉬운 점과 개선 방향
- **CSS-in-JS 미지원**: styled-components 같은 라이브러리 지원 필요
- **성능 최적화**: 100+개 파일에선 문제 없음. 그 이상의 대규모 프로젝트에서도 메모리 부족없이 잘 작동할지는 테스트가 필요
- **설정 UI**: 색상 제한의 경우 .stylesentryrc에 따로 정의해야하는 번거로움이 있음. 가이드라인 css파일을 읽고 자동제한 할 수 있는지 조사 필요

---

## (추가) 사용후기

### 원래 목적: 미사용 CSS 클래스 정리
Style Sentry를 만들게 된 본래 목적인 미사용 CSS 클래스 검출로도 잘 사용하고 있습니다. 팀 프로젝트에서 시간이 지나면서 쌓여있던 불필요한 스타일들을 체계적으로 정리할 수 있어서 코드베이스가 훨씬 깔끔해졌습니다.

### 또 다른 활용법: 컴포넌트 리팩토링

하지만 개발 과정에서 가장 유용했던 것은 **컴포넌트 분리 작업**이었습니다.

큰 컴포넌트를 여러 개의 작은 컴포넌트로 리팩토링할 때 JSX는 상대적으로 쉽게 분리할 수 있지만 SCSS 파일 분리는 까다로운 작업이었습니다. 기존에 하나의 SCSS 파일에 모든 스타일이 들어있는데 새로 분리한 컴포넌트에서 실제로 사용하는 클래스가 무엇인지 파악하기 어려웠거든요.

수동으로 하나씩 확인하기에는 시간이 오래 걸리고 실수하기도 쉬웠습니다.

**Style Sentry를 활용:**
1. 기존 SCSS 파일을 새 컴포넌트 폴더에 복사
2. 경고가 표시되는 클래스들만 삭제
3. 필요한 스타일만 남기고 정리 완료

처음에는 단순히 미사용 클래스를 찾아주는 코드 정리 도구 정도로 생각했는데 대규모 컴포넌트를 작은 단위로 분리하는 리팩토링 작업에도 활용해 시간을 크게 절약할 수 있었습니다. 👍

---

<Callout type="info" title="개인 프로젝트 포스트">
[cha-LINE](/blog/ko/codeLab/cha-line/) - SBI 증권 배당금 자동 수집 및 LINE 알림 봇
[Dead Internet Theory](/blog/ko/codeLab/dead-internet-theory/) - AI 페르소나 봇 댓글 자동화 시스템
[its-me](/blog/ko/codeLab/its-me) - AI 기반 RAG 인터랙티브 포트폴리오 챗봇
</Callout>

